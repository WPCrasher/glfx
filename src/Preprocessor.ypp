%name-prefix "prepro_"
%debug
%error-verbose
%output "src/PreprocessParser.cpp"
%defines "src/PreprocessParser.h"
%{
    #ifdef _MSC_VER
		// MS's C++ compiler is more strict than gcc
		// No unistd.h
		#define YY_NO_UNISTD_H
		// Direct IO functions (read and such)
		#include <io.h>
		// Disable the warning for yywrap
		#pragma warning( disable: 4003 )
		// Disable the warning about depracted naming of _read and friends
		#pragma warning( disable: 4996 )
		#define YY_NO_UNISTD_H
		#define YYERROR_VERBOSE
	#endif
	#include <stdio.h>
	#include <iostream>		// For std::cout and cerr
    #include <sstream>		// For std::ostringstream
    #include <vector>		// For std::vector
	#include "Preprocessor.h"
	extern void prepro_error(const char *s);
	#include "PreprocessLexer.h"
	#define YYSTYPE PreprocessorType
	#define YYDEBUG 1
	using namespace std;
	bool preproError=false;
	// We use a stack of booleans to handle #if #else #endif.
	// At the top of the stack is a value that is TRUE is we are in an active block, and FALSE otherwise.
	// So: ifdef, if, and ifndef all add either TRUE or FALSE to the stack.
	// else switches the value at the top of the stack
	// and endif pops the stack.
	vector<bool> activeBlockStack;
	vector<string> blockTestStack;
	extern int preproBracket;
	// We pass-through #if blocks.
	//vector<bool> passthroughBlockStack;
	void ClearParserState()
	{
		activeBlockStack.clear();
		blockTestStack.clear();
		preproError=false;
		preproBracket=0;
	}
	bool inActiveBlock()
	{
		if(!activeBlockStack.size())
			return true;
		return activeBlockStack.back();
	}
	void ifdef(string id)
	{
		bool result	=IsDefined(id)&&inActiveBlock();
		activeBlockStack.push_back(result);
		blockTestStack.push_back(("#ifdef ")+id);
//passthroughBlockStack.push_back(false);
		Skip();
	}
	void ifndef(string id)
	{
		bool result=(!IsDefined(id))&&inActiveBlock();
		activeBlockStack.push_back(result);
		blockTestStack.push_back(("#ifndef ")+id);
//		passthroughBlockStack.push_back(false);
		Skip();
	}
	bool hash_if(string id,Test test,int num=0)
	{
		if(test==IS_DEFINED)
		{
			return IsDefined(id);
		}
		if(test==NOT_DEFINED)
		{
			return !IsDefined(id);
		}
		const MacroDefinition *m=GetMacro(id);
		if(!m)
		{
			string str=string("Macro ")+id+string(" not defined");
			prepro_error(str.c_str());
			return false;
		}
		int value=atoi(m->definition[0].c_str());
		bool result=false;
		if(test==EQUALS)
		{
			result=(value==num);
		}
		else if(test==NONZERO)
		{
			result=(value!=0);
		}
		else
		{
			prepro_error("Can't handle this condition");
			return false;
		}
		return result;
	}
		//
	void apply_condition(string var,bool result)
	{
		activeBlockStack.push_back(result&&inActiveBlock());
		blockTestStack.push_back(var);
	}

	void endif()
	{
		//if(passthroughBlockStack.back())
		//	preproOutput<<"#endif\n";
		if(activeBlockStack.size()==0)
			prepro_error("Mismatched #endif");
		else
		{
			activeBlockStack.pop_back();
			blockTestStack.pop_back();
		//	passthroughBlockStack.pop_back();
		}
		Skip();
	}
	void hash_else()
	{
		//if (passthroughBlockStack.back())
		//	preproOutput << "#else\n";
		//else
		{
			if(activeBlockStack.size()==0)
			{
				prepro_error("Mismatched #else");
				return;
			}
			else
			{
				bool current = activeBlockStack.back();
				activeBlockStack.pop_back();
				activeBlockStack.push_back((!current)&&inActiveBlock());
				if(current)
					Skip();
			}
		}
		blockTestStack.back() += " #else";
	}
%}
/* declare tokens */
%token NUMBER
%token DEFINE IF IFDEF IFNDEF ELSE ENDIF IDENTIFIER IS_EQUAL COMMA LEFT_BRACKET RIGHT_BRACKET BOOLEAN_NOT DEFINED AND OR SYMBOL WHITESPACE
%token EOL MACRO_NAME
%%
prog: prog prepr
    | /* nothing */// matches at beginning of input
	{ // EOL is end of an expression
						//printf("\n= %d\n", $1);
	};

prepr : IF if_conditions
	{
		string var=$2.str;
		int num=$2.num;
		Test test=$2.test;
		apply_condition(var,$2.num!=0);
	}
	| MACRO_NAME optional_params
	{
		if(inActiveBlock())
		{
			string macro_name=$1.str;
			string str=ProcessMacro(macro_name,$2.strs);
			Write(str.c_str());
		}
	}
	| IFNDEF IDENTIFIER
	{
		string id=$2.str;
		ifndef(id);
	}
	| IFDEF IDENTIFIER
	{
		string id=$2.str;
		ifdef(id);
	}
	| DEFINE IDENTIFIER optional_param_decls optional_definition
	{
		string id=$2.str;
		vector<string> def=$4.strs;
		string params=$3.str;
		if(inActiveBlock())
			DefineMacro(id,params,def);
		std::ostringstream definition;
		definition<<"#define "<<id;
		if(params.length())
			definition<<"("<<params<<")";
		for(int i=0;i<def.size();i++)
			definition<<" "<<def[i];
		definition<<"\n";
		if(inActiveBlock())
			Write(definition.str().c_str());
	}
	| ELSE
	{
		hash_else();
	}
	| ENDIF
	{
		endif();
	}
	| EOL
		{
		}
	| NUMBER
		{
			Write($1.str.c_str());
		}
		| LEFT_BRACKET
		{
			Write($1.str.c_str());
		}
		| AND
		{
			Write($1.str.c_str());
		}
		| RIGHT_BRACKET
		{
			Write($1.str.c_str());
		}
		| SYMBOL
		{
			Write($1.str.c_str());
		}
		| COMMA
		{
			Write($1.str.c_str());
		};
optional_param_decls: LEFT_BRACKET param_decl_list RIGHT_BRACKET
				 {
					$$.str=$2.str;
				 }
				 |
				 {
					$$.str="";
				 };
param_decl_list : param_decl_list COMMA IDENTIFIER
			 {
				string s=$1.str+",";
				s+=$3.str;
				$$.str=s;
			 }
			 |
			IDENTIFIER
			 {
				 $$.str=$1.str;
			 };
optional_params: LEFT_BRACKET param_list RIGHT_BRACKET
				 {
					$$.str=$1.str+$2.str+$3.str;
					$$.strs=$2.strs;
				 }
				 |
				 {
					$$.str="";
					$$.strs.clear();
				 };
param_list : param_list COMMA rvalue
			 {
				string &el=$3.str;
				vector<string> &defs=$$.strs;
				defs=$1.strs;
				defs.push_back(el);
				$$.str=$1.str+$2.str+$3.str;
			 }
			 |
			rvalue
			 {
				string &el=$1.str;
				vector<string> &defs=$$.strs;
				defs.clear();
				defs.push_back(el);
				$$.str=el;
			 }
			 |
			 {
				$$.str="";
				 $$.strs.clear();
			 };
rvalue: IDENTIFIER optional_params
			 {
				 $$.str=$1.str+$2.str;
			 }
			 |
			 rvalue SYMBOL rvalue
			 {
				string &r=$1.str;
				string &s=$2.str;
				string &v=$3.str;
				$$.str=r+s+v;
			 }
				| LEFT_BRACKET rvalue RIGHT_BRACKET
			 {
				 $$.str=$1.str+$2.str+$3.str;
			 }
			 |
			 NUMBER
			 {
				 $$.str=$1.str;
			};

if_conditions: if_conditions OR if_condition
			{
				$$.num=$1.num|$3.num;
				$$.str=($1.str+"|")+$3.str;
			}
			 | if_condition
			{
				$$.str=$1.str;
				$$.num=$1.num;
			};
if_condition: IDENTIFIER if_test
					{
						string id=$1.str;
						int num=$2.num;
						Test test=$2.test;
						$$.num=hash_if(id,test,num);
						$$.str=$1.str+$2.str;
					}
				| optional_boolean_not defined_test
					{
						$$.test=$1.test;
						Test test=$1.test;
						string id=$1.str+$2.str;
						$$.num=hash_if(id,$1.test);
						$$.str=id;
					};
				| NUMBER
					{
						$$.test=NONZERO;
						string id=$1.str;
						$$.num=($1.num!=0);
						$$.str=id;
					};
defined_test: DEFINED LEFT_BRACKET IDENTIFIER RIGHT_BRACKET
					{
						$$.str="defined(";
						$$.str+=$3.str;
						$$.str+=")";
					};
optional_boolean_not: BOOLEAN_NOT
					{
						$$.str="!";
						$$.test=NOT_DEFINED;
					}
					|
					{
						$$.str="";
						$$.test=IS_DEFINED;
					};

if_test: IS_EQUAL NUMBER
					{
						$$.num=$2.num;
						$$.test=EQUALS;
						$$.str="==";
						$$.str+=$2.str;
					}
					|
					{
						$$.str="";
						$$.num=1;
						$$.test=NONZERO;
					};

optional_definition : optional_definition definition_element
					  {
							string &el=$2.str;
							vector<string> &defs=$$.strs;
							defs=$1.strs;
							defs.push_back(el);
					  }
					  |
					  definition_element
					  {
							string &el=$1.str;
							vector<string> &defs=$$.strs;
							defs.clear();
							defs.push_back(el);
					  };
					  |
					  {
						  $$.strs.clear();
					  };
definition_element: IDENTIFIER
					  {
						  $$.str=$1.str;
					  }
					 | LEFT_BRACKET
					  {
						  $$.str=$1.str;
					  }
					 | RIGHT_BRACKET
					  {
						  $$.str=$1.str;
					  }
					 | COMMA
					  {
						  $$.str=$1.str;
					  }
						| NUMBER
						{
						  $$.str=$1.str;
						}
						| SYMBOL
						{
							$$.str=$1.str;
						}
						| WHITESPACE
						{
							$$.str=$1.str;
						}
%%

extern std::string currentFilename;
void prepro_error(const char *errmsg)
{
	using namespace std;
    ostringstream errMsg;
	int lex_linenumber=prepro_get_lineno();
	int true_linenumber=lex_linenumber;//+last_linenumber-global_linenumber;
	const char *txt=prepro_get_text();
	if(*txt)
		errMsg<<currentFilename<<"("<< true_linenumber<<") : error: \""<< txt<<"\" Preprocessor "<<errmsg;
	else
		errMsg<<currentFilename<<"("<< true_linenumber<<") : error: Preprocessor "<<errmsg;
	std::cerr<<errMsg.str().c_str()<<std::endl;
  //  throw std::runtime_error(errMsg.str());
	preproError=true;
}