%name-prefix "prepro_"
%output "PreprocessParser.cpp"
%defines "PreprocessParser.h"
%{
    #ifdef _MSC_VER
		// MS's C++ compiler is more strict than gcc
		// No unistd.h
		#define YY_NO_UNISTD_H
		// Direct IO functions (read and such)
		#include <io.h>
		// Disable the warning for yywrap
		#pragma warning( disable: 4003 )
		// Disable the warning about depracted naming of _read and friends
		#pragma warning( disable: 4996 )
	#endif
	#include <stdio.h>
	#include <iostream>		// For std::cout and cerr
    #include <sstream>		// For std::ostringstream
    #include <vector>		// For std::vector
	#include "Preprocessor.h"
	extern void prepro_error(const char *s);
	#include "PreprocessLexer.h"
	#define YYSTYPE PreprocessorType
	using namespace std;
	// We use a stack of booleans to handle #if #else #endif.
	// At the top of the stack is a value that is TRUE is we are in an active block, and FALSE otherwise.
	// So: ifdef, if, and ifndef all add either TRUE or FALSE to the stack.
	// else switches the value at the top of the stack
	// and endif pops the stack.
	vector<bool> activeBlockStack;
	vector<string> blockTestStack;
	bool inActiveBlock()
	{
		if(!activeBlockStack.size())
			return true;
		return activeBlockStack.back();
	}
%}
/* declare tokens */
%token NUMBER
%token DEFINE IFDEF IFNDEF ELSE ENDIF IDENTIFIER MACRO_DEFINITION
%token EOL
%%
prog: prog prepr
    | /* nothing */// matches at beginning of input
	{ // EOL is end of an expression
						//printf("\n= %d\n", $1);
	};

prepr : IFNDEF IDENTIFIER
	{
		string str=$1.str;
		string id=$2.str;
		activeBlockStack.push_back(true);
		blockTestStack.push_back((str+" ")+id);
	}
	| IFDEF IDENTIFIER
	{
		string str=$1.str;
		string id=$2.str;
		activeBlockStack.push_back(true);
		blockTestStack.push_back((str+" ")+id);
	}
	| DEFINE IDENTIFIER optional_definition
	{
		string str=$1.str;
		string id=$2.str;
		string def=$3.str;
	}
	| ELSE
	{
		string str=$1.str;
		bool current=activeBlockStack.back();
		activeBlockStack.pop_back();
		activeBlockStack.push_back(!current);
		blockTestStack.back()+=" #else";
	}
	| ENDIF
	{
		string str=$1.str;
		activeBlockStack.pop_back();
		blockTestStack.pop_back();
	};

optional_definition : MACRO_DEFINITION
					  {
						  $$.str=$1.str;
					  }
					  |
					  NUMBER
					  {
						  $$.str=$1.str;
					  }
					  |
					  {
						  $$.str="";
					  }
%%
extern std::string currentFilename;
void prepro_error(const char *errmsg)
{
	using namespace std;
    ostringstream errMsg;
	int lex_linenumber=prepro_get_lineno();
	int true_linenumber=lex_linenumber;//+last_linenumber-global_linenumber;
    errMsg<<currentFilename<<"("<< true_linenumber<<") : error: \""<< prepro_get_text()<<"\" Preprocessor "<<errmsg;
	std::cerr<<errMsg.str().c_str()<<std::endl;
  //  throw std::runtime_error(errMsg.str());
}