%name-prefix "prepro_"
%output "src/PreprocessParser.cpp"
%defines "src/PreprocessParser.h"
%{
    #ifdef _MSC_VER
		// MS's C++ compiler is more strict than gcc
		// No unistd.h
		#define YY_NO_UNISTD_H
		// Direct IO functions (read and such)
		#include <io.h>
		// Disable the warning for yywrap
		#pragma warning( disable: 4003 )
		// Disable the warning about depracted naming of _read and friends
		#pragma warning( disable: 4996 )
	#endif
	#include <stdio.h>
	#include <iostream>		// For std::cout and cerr
    #include <sstream>		// For std::ostringstream
    #include <vector>		// For std::vector
	#include "Preprocessor.h"
	extern void prepro_error(const char *s);
	#include "PreprocessLexer.h"
	#define YYSTYPE PreprocessorType
	using namespace std;
	// We use a stack of booleans to handle #if #else #endif.
	// At the top of the stack is a value that is TRUE is we are in an active block, and FALSE otherwise.
	// So: ifdef, if, and ifndef all add either TRUE or FALSE to the stack.
	// else switches the value at the top of the stack
	// and endif pops the stack.
	vector<bool> activeBlockStack;
	vector<string> blockTestStack;
	// We pass-through #if blocks.
	//vector<bool> passthroughBlockStack;
	void ClearParserState()
	{
		activeBlockStack.clear();
		blockTestStack.clear();
	//	passthroughBlockStack.clear();
	}
	bool inActiveBlock()
	{
		if(!activeBlockStack.size())
			return true;
		return activeBlockStack.back();
	}
	void ifdef(string id)
	{
		bool result	=IsDefined(id)&&inActiveBlock();
		activeBlockStack.push_back(result);
		blockTestStack.push_back(("#ifdef ")+id);
//passthroughBlockStack.push_back(false);
		//WriteLineNumber();
	}
	void ifndef(string id)
	{
		bool result=(!IsDefined(id))&&inActiveBlock();
		activeBlockStack.push_back(result);
		blockTestStack.push_back(("#ifndef ")+id);
//		passthroughBlockStack.push_back(false);
		//WriteLineNumber();
	}
	bool hash_if(string id,Test test,int num=0)
	{
		if(test==IS_DEFINED)
		{
			return IsDefined(id);
		}
		if(test==NOT_DEFINED)
		{
			return !IsDefined(id);
		}
		const MacroDefinition *m=GetMacro(id);
		if(!m)
		{
			string str=string("Macro ")+id+string(" not defined");
			prepro_error(str.c_str());
			return false;
		}
		int value=atoi(m->definition.c_str());
		bool result=false;
		if(test==EQUALS)
		{
			result=(value==num);
		}
		else if(test==NONZERO)
		{
			result=(value!=0);
		}
		else
		{
			prepro_error("Can't handle this condition");
			return false;
		}
		return result;
	}
		//
	void apply_condition(string var,bool result)
	{
		activeBlockStack.push_back(result&&inActiveBlock());
		blockTestStack.push_back(var);
	}
	void endif()
	{
		//if(passthroughBlockStack.back())
		//	preproOutput<<"#endif\n";
		if(activeBlockStack.size()==0)
			prepro_error("Mismatched #endif");
		else
		{
			activeBlockStack.pop_back();
			blockTestStack.pop_back();
		//	passthroughBlockStack.pop_back();
		}
		WriteLineNumber();
	}
	void hash_else()
	{
		//if (passthroughBlockStack.back())
		//	preproOutput << "#else\n";
		//else
		{
			if(activeBlockStack.size()==0)
			{
				prepro_error("Mismatched #else");
				return;
			}
			else
			{
				bool current = activeBlockStack.back();
				activeBlockStack.pop_back();
				activeBlockStack.push_back((!current)&&inActiveBlock());
				if(current)
					WriteLineNumber();
			}
		}
		blockTestStack.back() += " #else";
	}
%}
/* declare tokens */
%token NUMBER
%token DEFINE IF IFDEF IFNDEF ELSE ENDIF IDENTIFIER MACRO_DEFINITION IS_EQUAL COMMA LEFT_BRACKET RIGHT_BRACKET BOOLEAN_NOT DEFINED AND OR
%token EOL
%%
prog: prog prepr
    | /* nothing */// matches at beginning of input
	{ // EOL is end of an expression
						//printf("\n= %d\n", $1);
	};

prepr : IF if_conditions
	{
		string var=$2.str;
		int num=$2.num;
		Test test=$2.test;
		apply_condition(var,$2.num!=0);
	}
	| EOL
	{
	}
	| IFNDEF IDENTIFIER
	{
		string id=$2.str;
		ifndef(id);
	}
	| IFDEF IDENTIFIER
	{
		string id=$2.str;
		ifdef(id);
	}
	| DEFINE IDENTIFIER optional_params optional_definition
	{
		string id=$2.str;
		string def=$4.str;
		string params=$3.str;
		if(inActiveBlock())
		DefineMacro(id,def);
		std::ostringstream definition;
		definition<<"#define "<<id<<params;
		if(def.length())
			definition<<" "<<def;
		definition<<"\n";
		Write(definition.str().c_str());
	}
	| ELSE
	{
		hash_else();
	}
	| ENDIF
	{
		endif();
	};
optional_params: LEFT_BRACKET param_list RIGHT_BRACKET
				 {
					$$.str="(";
					$$.str+=$2.str;
					$$.str+=")";
				 }
				 |
				 {
					$$.str="";
				 };
param_list : param_list COMMA IDENTIFIER
			 {
				$$.str=$1.str+",";
				$$.str+=$3.str;
			 }
			 |
			IDENTIFIER
			 {
				 $$.str=$1.str;
			 };
if_conditions: if_conditions OR if_condition
			{
				$$.num=$1.num|$3.num;
				$$.str=($1.str+"|")+$3.str;
			}
			 | if_condition
			{
				$$.str=$1.str;
				$$.num=$1.num;
			};
if_condition: IDENTIFIER if_test
					{
						string id=$1.str;
						int num=$2.num;
						Test test=$2.test;
						$$.num=hash_if(id,test,num);
						$$.str=$1.str+$2.str;
					}
				| optional_boolean_not defined_test
					{
						$$.test=$1.test;
						Test test=$1.test;
						string id=$1.str+$2.str;
						$$.num=hash_if(id,$1.test);
						$$.str=id;
					};
				| NUMBER
					{
						$$.test=NONZERO;
						string id=$1.str;
						$$.num=($1.num!=0);
						$$.str=id;
					};
defined_test: DEFINED LEFT_BRACKET IDENTIFIER RIGHT_BRACKET
					{
						$$.str="defined(";
						$$.str+=$3.str;
						$$.str+=")";
					};
optional_boolean_not: BOOLEAN_NOT
					{
						$$.str="!";
						$$.test=NOT_DEFINED;
					}
					|
					{
						$$.str="";
						$$.test=IS_DEFINED;
					};

if_test: IS_EQUAL NUMBER
					{
						$$.num=$2.num;
						$$.test=EQUALS;
						$$.str="==";
						$$.str+=$2.str;
					}
					|
					{
						$$.str="";
						$$.num=1;
						$$.test=NONZERO;
					};

optional_definition : MACRO_DEFINITION
					  {
						  $$.str=$1.str;
					  }
					  |
					  NUMBER
					  {
						  $$.str=$1.str;
					  }
					  |
					  {
						  $$.str="";
					  }
%%

extern std::string currentFilename;
void prepro_error(const char *errmsg)
{
	using namespace std;
    ostringstream errMsg;
	int lex_linenumber=prepro_get_lineno();
	int true_linenumber=lex_linenumber;//+last_linenumber-global_linenumber;
    errMsg<<currentFilename<<"("<< true_linenumber<<") : error: \""<< prepro_get_text()<<"\" Preprocessor "<<errmsg;
	std::cerr<<errMsg.str().c_str()<<std::endl;
  //  throw std::runtime_error(errMsg.str());
}