/*
Flex and Bison files have three sections:

the first is sort of "control" information,
the second is the actual token/grammar definitions,
the last is C code to be copied verbatim to the output.
*/
%option yylineno
%option noyywrap
%option stack
%option fast
%option ecs
%option prefix="glfx"
%option outfile="src/glfxScanner.cpp" header-file="src/glfxScanner.h"

%{

	//#define YYFPRINTF glfxprintf
	#define YYDEBUG 1
    #ifdef _MSC_VER
		// MS's C++ compiler is more strict than gcc
		// No unistd.h
		#define YY_NO_UNISTD_H
		// Direct IO functions (read and such)
		#include <io.h>
		// Disable the warning for yywrap
		#pragma warning( disable: 4003 )
		// Disable the warning about deprecated naming of _read and friends
		#pragma warning( disable: 4996 )
    #endif

    #ifdef _M_X64
		// flex is (still) incompatible with x64
		// it makes some casts from pointers to integers (pointer casts seem to be fixed in the latest version) and from size_t to integers
		// it should work though, nothing too serious
		#pragma warning( disable:4267 )
		#pragma warning( disable:4244 )
    #endif

    #include <iostream>
    #include <string>
    #include <sstream>
#include <stdarg.h>

    #include "glfxParser.h"
    #include "glfxClasses.h"
    #include "glfxEffect.h"

    // tokens from parser generator
    #include "glfxLALRParser.hpp"

    static void errLex(const char* tok);

    using namespace std;
    using namespace glfxParser;
	static int brace=0;
	#pragma optimize("",off)
	void glfxWrite(const char *txt)
	{
		gEffect->m_sharedCode<<txt;
	}
	int glfxprintf ( FILE * , const char * format_str, ... )
	{
		int size=strlen(format_str)+100;
		std::string str;
		va_list ap;
		int n=-1;
		while(n<0||n>=size)
		{
			str.resize(size);
			va_start(ap, format_str);
			//n = vsnprintf_s((char *)str.c_str(), size, size,format_str, ap);
			n = vsnprintf((char *)str.c_str(), size,format_str, ap);
			va_end(ap);
			if(n> -1 && n < size)
			{
				str.resize(n);
				break;
			}
			if (n > -1)
				size=n+1;
			else
				size*=2;
		}
		std::cout<<str.c_str();
		return strlen(str.c_str());
	}
	int stdReturn(int u)
	{
		glfxlval.lineno=yylineno;
		glfxlval.strs[0]=yytext;
		return u;
	}
%}

%x IN_SHADER IN_DEFINE IN_SHADER_COMPILE IN_RENDER_STATE IN_STRUCT IN_TEXTURE_DECL IN_UNIFORM_DECL

ID_BLCK [a-zA-Z][a-zA-Z0-9_]*
NUM_BLCK 0|([1-9][0-9]*)
HEX_BLCK 0x[0-9A-Fa-f][0-9A-Fa-f]*
STR_BLCK \"[^"\n]*\"
FLOAT_BLCK [0-9]*((\.[0-9])|([0-9]\.))[0-9]*f?

/* The %% means that we are done with the CONTROL section, and now move onto the token definitions
<INITIAL>"patch"|"centroid"						if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.strs[0]=yytext; return STORAGET;}*/
/*
<INITIAL>"uniform"								{
													glfxPushState(IN_UNIFORM_DECL);
													return UNIFORM;
												}
<IN_UNIFORM_DECL>"Texture2DMS"					{
													glfxlval.num=TEXTURE2DMS;
													return TEXTURE2DMS;
												}
<IN_UNIFORM_DECL>"<"							{
													return '<';
												}
<IN_UNIFORM_DECL>">"							{
													return '>';
												}
<IN_UNIFORM_DECL>{ID_BLCK}						{
													glfxlval.strs[0]=yytext;
													return IDENTIFIER;
												}
<IN_UNIFORM_DECL>";"							{
													glfxPopState();
													return ';';
												}
<IN_SHADER>[^\n{}]*\n							{
													glfxlval.strs[0]=yytext;
													return SHADER_LINE;
												}
												 ',' ':' '=' '.' '+' '-' '*' '/' '[' ']'
*/
%%
<INITIAL>"#"define								{
													if(gLexPassthrough)
														glfxWrite(yytext); 
													glfxPushState(IN_DEFINE);
													return DEFINE;
												}
<INITIAL>"[numthreads("{NUM_BLCK}","{NUM_BLCK}","{NUM_BLCK}")]" {
													glfxlval.strs[0]=yytext;
													return CS_LAYOUT;
												}
<IN_DEFINE>[^\n]+								{
													if(gLexPassthrough)
														glfxWrite(yytext); 
													return MACRO_DEFINITION;
												}
<IN_DEFINE>\n									{
													if(gLexPassthrough)
														glfxWrite(yytext); 
													glfxPopState();
													return EOL;
												}
<INITIAL>"layout"								{
													/*layout(local_size_x=u,local_size_y=v,local_size_z=w) in;*/
													glfxlval.lineno=yylineno;
													glfxlval.strs[0]=yytext;
													glfxPushState(IN_SHADER_COMPILE);
													return LAYOUT;
												}
<INITIAL>"struct"								{
													glfxPushState(IN_STRUCT);
													return STRUCT;
												}
<INITIAL>"SV_DispatchThreadID"					glfxlval.strs[0]=yytext;		return INPUT_SEMANTIC;
<INITIAL>"gl_GlobalInvocationID"				glfxlval.strs[0]=yytext;		return INPUT_SEMANTIC;
<INITIAL>"program"								glfxlval.boolean=false;		return PROGRAM;
<INITIAL>"stages"								glfxlval.boolean=true;		return PROGRAM;
<INITIAL>"technique"							glfxlval.boolean=false;		return TECHNIQUE;
<INITIAL>"pass"									glfxlval.boolean=false;		return PASS;
<INITIAL>"group"								glfxlval.boolean=false;		return GROUP;
<INITIAL>"shader"								{
													glfxlval.lineno=yylineno;	glfxlval.strs[0]=yytext;	return SHADER;
												}
<INITIAL>"interface"							glfxlval.lineno=yylineno;	glfxlval.strs[0]=yytext;	return INTERFACE;
<INITIAL>"sampler"								glfxlval.lineno=yylineno;	glfxlval.strs[0]=yytext;	return SAMPLER;
<INITIAL>"profile"								{
													glfxPushState(IN_SHADER_COMPILE);
													return PROFILE;
												}

<INITIAL>"RW_TEXTURE3D_FLOAT4"					{
													glfxPushState(IN_TEXTURE_DECL);
													return RW_TEXTURE3D_FLOAT4;
												}
<IN_TEXTURE_DECL>","			{
													glfxlval.strs[0]=yytext;
													glfxPopState();
													return ',';
												}
<INITIAL,IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER>"#line"	{
														glfxlval.lineno=yylineno;
														glfxlval.strs[0]=yytext;
														return LINE;
													}
<INITIAL>^"#include"[\t ]+{STR_BLCK}[\t ]*\n	{
													string tmp(yytext);
													size_t firstLoc	=tmp.find('"')+1;
													size_t secondLoc=tmp.find('"', firstLoc);
													glfxlval.strs[0]=tmp.substr(firstLoc, secondLoc-firstLoc);
													glfxlval.lineno	=yylineno-1; // flex has already jumped one line, since \n was eaten
													return INCLUDE;
												}
<INITIAL>"vs"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=VERTEX_SHADER; return SHADER_TYPE;}
<INITIAL>"tc"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=TESSELATION_CONTROL_SHADER; return SHADER_TYPE;}
<INITIAL>"te"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=TESSELATION_EVALUATION_SHADER; return SHADER_TYPE;}
<INITIAL>"gs"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=GEOMETRY_SHADER; return SHADER_TYPE;}
<INITIAL>"fs"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=FRAGMENT_SHADER; return SHADER_TYPE;}
<INITIAL>"cs"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=COMPUTE_SHADER; return SHADER_TYPE;}

<INITIAL>"RasterizerState"						{
													glfxlval.lineno=yylineno;
													renderState=RASTERIZER_STATE;
													glfxPushState(IN_RENDER_STATE);
													return RENDER_STATE_DECL;
												}
<INITIAL>"DepthStencilState"					{
													glfxlval.lineno=yylineno;
													renderState=DEPTHSTENCIL_STATE;
													glfxPushState(IN_RENDER_STATE);
													return RENDER_STATE_DECL;
												}
<INITIAL>"BlendState"							{
													glfxlval.lineno=yylineno;
													renderState=BLEND_STATE;
													glfxPushState(IN_RENDER_STATE);
													return RENDER_STATE_DECL;
												}
<INITIAL>"SamplerState"							{
													glfxlval.lineno=yylineno;
													renderState=SAMPLER_STATE;
													glfxPushState(IN_RENDER_STATE);
													return RENDER_STATE_DECL;
												}
<INITIAL>"SetVertexShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=VERTEX_SHADER; 					
														glfxlval.sCommand=SetVertexShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetHullShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=TESSELATION_CONTROL_SHADER;
														glfxlval.sCommand=SetHullShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetDomainShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=TESSELATION_EVALUATION_SHADER; 	
														glfxlval.sCommand=SetDomainShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetGeometryShader"					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=GEOMETRY_SHADER; 				
														glfxlval.sCommand=SetGeometryShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetPixelShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=FRAGMENT_SHADER; 				
														glfxlval.sCommand=SetFragmentShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetFragmentShader"					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=FRAGMENT_SHADER; 				
														glfxlval.sCommand=SetFragmentShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetComputeShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=COMPUTE_SHADER;	 				
														glfxlval.sCommand=SetComputeShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetRasterizerState"					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sCommand=SetRasterizerState;
														return SET_RASTERIZER_COMMAND;
													}
												}
<INITIAL>"SetDepthStencilState"					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sCommand=SetDepthStencilState;
														return SET_DEPTH_COMMAND;
													}
												}
<INITIAL>"SetBlendState"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sCommand=SetBlendState;
														return SET_BLEND_COMMAND;
													}
												}

<INITIAL>"VertexShader"							{glfxlval.lineno=yylineno;	glfxlval.sType=VERTEX_SHADER;	glfxPushState(IN_SHADER_COMPILE); return DECL_SHADER;}
<INITIAL>"PixelShader"							{glfxlval.lineno=yylineno;	glfxlval.sType=FRAGMENT_SHADER;	glfxPushState(IN_SHADER_COMPILE); return DECL_SHADER;}
<INITIAL>"FragmentShader"						{glfxlval.lineno=yylineno;	glfxlval.sType=FRAGMENT_SHADER;	glfxPushState(IN_SHADER_COMPILE); return DECL_SHADER;}
<IN_SHADER_COMPILE>"CompileShader"				{
													glfxlval.lineno=yylineno;
													return COMPILE_SHADER;
												}
<IN_SHADER>"vec2"	{
													glfxlval.lineno=yylineno;
													glfxlval.strs[0]=yytext;
													return IDENTIFIER;
												}
<IN_SHADER>"return"	{
													glfxlval.lineno=yylineno;
													glfxlval.strs[0]=yytext;
													return RETURN;
												}
<IN_SHADER>"break"								return stdReturn(BREAK);
<IN_SHADER>"continue"							return stdReturn(CONTINUE);
<IN_SHADER>"do"									return stdReturn(DO);
<IN_SHADER>"for"								return stdReturn(FOR);
<IN_SHADER>"goto"								return stdReturn(GOTO);
<IN_SHADER>"if"									return stdReturn(IF);
<IN_SHADER>"while"								return stdReturn(WHILE);
											

<IN_SHADER>";"									{
													glfxlval.lineno=yylineno;
													glfxlval.strs[0]=yytext;
													return ';';
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER>{FLOAT_BLCK}	{
													glfxlval.lineno=yylineno;
													glfxlval.fnum=(float)atof(yytext);
													return FLOAT;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER>{NUM_BLCK}	{
													glfxlval.lineno=yylineno;
													glfxlval.num=atoi(yytext);
													glfxlval.strs[0]=yytext;
													return NUM;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER,IN_STRUCT,IN_TEXTURE_DECL>{ID_BLCK}	{
													glfxlval.lineno=yylineno;
													glfxlval.strs[0]=yytext;
													return IDENTIFIER;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER>"("			{
													glfxlval.strs[0]=yytext;
													return '(';
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER>")"			{
													glfxlval.strs[0]=yytext;
													return ')';
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER>"["			{
													glfxlval.strs[0]=yytext;
													return '[';
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER>"]"			{
													glfxlval.strs[0]=yytext;
													return ']';
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER>","			{
													glfxlval.strs[0]=yytext;
													return ',';
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_SHADER>"="			{
													glfxlval.strs[0]=yytext;
													return '=';
												}
<IN_SHADER>"<"									return stdReturn('<');
<IN_SHADER>">"									return stdReturn('>');
<IN_SHADER>"."			{
													glfxlval.strs[0]=yytext;
													return '.';
												} 

<IN_SHADER>"*="									return stdReturn(TIMES_EQUALS);
<IN_SHADER>"/="									return stdReturn(OVER_EQUALS);
<IN_SHADER>"%="									return stdReturn(PERCENT_EQUALS);
<IN_SHADER>"+="									return stdReturn(PLUS_EQUALS);
<IN_SHADER>"-="									return stdReturn(MINUS_EQUALS);
<IN_SHADER>"<<="								return stdReturn(LEFT_SHIFT_EQUALS);
<IN_SHADER>">>="								return stdReturn(RIGHT_SHIFT_EQUALS);
<IN_SHADER>"&="									return stdReturn(AND_EQUALS);
<IN_SHADER>"^="									return stdReturn(XOR_EQUALS);
<IN_SHADER>"|="									return stdReturn(OR_EQUALS);
<IN_SHADER>"||"									return stdReturn(OR);
<IN_SHADER>"&&"									return stdReturn(AND);

<IN_SHADER>"<="									return stdReturn(LESS_EQ);
<IN_SHADER>">="									return stdReturn(GRTR_EQ);

<IN_SHADER>"<<"									return stdReturn(LEFT_SHIFT);
<IN_SHADER>">>"									return stdReturn(RIGHT_SHIFT);

<IN_SHADER>"++"									return stdReturn(PLUS_PLUS);
<IN_SHADER>"--"									return stdReturn(MINUS_MINUS);
<IN_SHADER>"=="									return stdReturn(EQ_EQ);
<IN_SHADER>"!="									return stdReturn(NOT_EQ);

<IN_SHADER>"+"			{
													glfxlval.strs[0]=yytext;
													return '+';
												}  
<IN_SHADER>"-"			{
													glfxlval.strs[0]=yytext;
													return '-';
												}   
<IN_SHADER>"*"			{
													glfxlval.strs[0]=yytext;
													return '*';
												}    
<IN_SHADER>"/"			{
													glfxlval.strs[0]=yytext;
													return '/';
												}

<IN_SHADER_COMPILE,IN_TEXTURE_DECL>";"			{
													glfxlval.strs[0]=yytext;
													glfxPopState();
													return ';';
												}
<IN_RENDER_STATE,IN_STRUCT>";"					{
													glfxlval.strs[0]=yytext;
													if(!brace)
														glfxPopState();
													return ';';
												}
<INITIAL>{STR_BLCK}								{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.strs[0]=yytext;
														return QUOTED_STRING;
													}
												}
<INITIAL>{HEX_BLCK}								{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.unum=strtoul(yytext, NULL, 16);
														glfxlval.strs[0]=yytext;
														return NUM;
													}
												}
<INITIAL>{NUM_BLCK}								{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.num=atoi(yytext);
														glfxlval.strs[0]=yytext;
														return NUM;
													}
												}
<INITIAL>{FLOAT_BLCK}							if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.fnum=(float)atof(yytext); return FLOAT;}
<INITIAL>"in"|"out"								if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return STORAGEQ;}
<INITIAL>"gl_FragDepth"							if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return GL_FRAGDEPTH;}
<INITIAL>"true"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.num=1; return NUM;}
<INITIAL>"false"								if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.num=0; return NUM;}
<INITIAL>{ID_BLCK}								{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.strs[0]=yytext;
														return IDENTIFIER;
													}
												}
<INITIAL>{ID_BLCK}"::"{ID_BLCK}					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.strs[0]=yytext;
														return IDENTIFIER;
													}
												}
<INITIAL>"("									if(gLexPassthrough) glfxWrite(yytext); else {return '(';}
<INITIAL>")"									if(gLexPassthrough) glfxWrite(yytext); else {return ')';}
<INITIAL>"{"									{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														if(read_shader)
														{
															brace++;
															glfxPushState(IN_SHADER);
														}
														return '{';
													}
												}
<INITIAL>"}"									{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														return '}';
													}//"["[\t ]*"]"						if(gLexPassthrough) glfxWrite(yytext); else {return EMPTY_ARRAY_BRACKETS;}
												}
<INITIAL>"["									if(gLexPassthrough) glfxWrite(yytext); else {return '[';}
<INITIAL>"]"									if(gLexPassthrough) glfxWrite(yytext); else {return ']';}
<INITIAL>","									if(gLexPassthrough) glfxWrite(yytext); else {return ',';}
<INITIAL>"="									if(gLexPassthrough) glfxWrite(yytext); else {return '=';}
<INITIAL>";"									if(gLexPassthrough) glfxWrite(yytext); else {return ';';}
<INITIAL>":"									if(gLexPassthrough) glfxWrite(yytext); else {return ':';}
<IN_STRUCT>":"									return ':';
<INITIAL,IN_RENDER_STATE,IN_SHADER>\/\/[^\n\\]*(\\+[^\\][^\n\\]*)*\n		{
													if(gLexPassthrough)
														glfxWrite(yytext); // Single line comment (with possible continuation)
												}
<INITIAL,IN_RENDER_STATE,IN_SHADER>\/\*[^*]*\*(([^*/][^*]*)*\*)*\/		{
													if(gLexPassthrough)
														glfxWrite(yytext); // Multiline comment
												}
<INITIAL,IN_SHADER>[\t\n ]						{
													if(gLexPassthrough) glfxWrite(yytext);
												}
<IN_RENDER_STATE,IN_STRUCT>[\t\n ]				{}// Without this line, the yylineno would get out of whack.
<INITIAL>.										if(gLexPassthrough) glfxWrite(yytext); else {errLex(yytext);}
<IN_SHADER,IN_RENDER_STATE,IN_STRUCT>"{"		{
													glfxlval.strs[0]=yytext;
													brace++;
													return '{';
												}
<IN_SHADER>"}"									{
													glfxlval.strs[0]=yytext;
													brace--;
													if(!brace)
													{
														glfxPopState();
														return '}';
													}
													return '}';
												}
<IN_RENDER_STATE,IN_STRUCT>"}"					{
													glfxlval.strs[0]=yytext;
													brace--;
													return '}';
												}
%%
void glfxPushState(int s)
{
	yy_push_state(s);
}
void glfxPopState()
{
	if(yy_start_stack_ptr<=0)
		glfxerror("Stack underflow");
	else
		yy_pop_state();
}
void glfxPopAllStates()
{
	while(yy_start_stack_ptr>0)
		yy_pop_state();
}
const char *glfxGetStateText()
{
	switch(YYSTATE)
	{
	case IN_SHADER:
		return "shader";
	case IN_DEFINE:
		return "macro definition";
	case IN_SHADER_COMPILE:
		return "shader compile";
	case IN_RENDER_STATE:
		return "render state def";
	default:
		return "default state";
	};
	return "";
}
void resetGlfxParse()
{
	glfxdebug=0;
	brace=0;
	glfxset_lineno(1);
	glfxPopAllStates();
}

void errLex(const char* tok)
{
    ostringstream errMsg;
    
    errMsg<<"0("<<yylineno<<") : error: Unkown token '"<<tok<<'\'';
   // throw errMsg.str();
	glfxerror(errMsg.str().c_str());
}

string glfxreadblock(unsigned char openChar, unsigned char closeChar)
{
    string str;
    int braceBalance=0;
    int c;
    bool done=false;
    do {
        c=yyinput();
        if(c<=0)
		{
            throw "Brace balance error\n";
		}
        str+=(unsigned char)c;
		if((unsigned char)c==openChar)
		{
            braceBalance++;
		}
        else if((unsigned char)c==closeChar)
		{
            braceBalance--;
            if(braceBalance<0)
			{
                throw "Brace balance error\n";
			}
            else if(braceBalance==0)
                done=true;
        }
    } while(!done);
    return str;
}
