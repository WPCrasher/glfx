/*
Flex and Bison files have three sections:

the first is sort of "control" information,
the second is the actual token/grammar definitions,
the last is C code to be copied verbatim to the output.
*/
%option yylineno
%option noyywrap
%option fast
%option ecs
%option prefix="glfx"
%option outfile="src/glfxScanner.cpp" header-file="src/glfxScanner.h"

%{
    #ifdef _MSC_VER
    // MS's C++ compiler is more strict than gcc

    // No unistd.h
    #define YY_NO_UNISTD_H

    // Direct IO functions (read and such)
    #include <io.h>

    // Disable the warning for yywrap
    #pragma warning( disable: 4003 )

    // Disable the warning about depracted naming of _read and friends
    #pragma warning( disable: 4996 )

    #endif

    #ifdef _M_X64
    // flex is (still) incompatible with x64
    // it makes some casts from pointers to integers (pointer casts seem to be fixed in the latest version) and from size_t to integers
    // it should work though, nothing too serious
    #pragma warning( disable:4267 )
    #pragma warning( disable:4244 )
    #endif

    #include <iostream>
    #include <string>
    #include <sstream>

    #include "glfxParser.h"
    #include "glfxClasses.h"
    #include "glfxEffect.h"

    // tokens from parser generator
    #include "glfxLALRParser.hpp"

    static void errLex(const char* tok);

    using namespace std;
    using namespace glfxParser;
#pragma optimize("",off)
%}

ID_BLCK [a-zA-Z\.:][a-zA-Z0-9_\.:]*
NUM_BLCK 0|([1-9][0-9]*)
STR_BLCK \"[^"\n]*\"
FLOAT_BLCK [0-9]*((\.[0-9])|([0-9]\.))[0-9]*

/* The %% means that we are done with the CONTROL section, and now move onto the token definitions*/
%%
CS_LAYOUT							if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.strs[0]=yytext;return LAYOUT;}
"program"							glfxlval.boolean=false; return PROGRAM;
"stages"							glfxlval.boolean=true; return PROGRAM;
"technique"							glfxlval.boolean=false; return TECHNIQUE;
"pass"								glfxlval.boolean=false; return PASS;
"group"								glfxlval.boolean=false; return GROUP;
"shader"							glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return SHADER;
"interface"							glfxlval.lineno=yylineno; return INTERFACE;
"sampler"							glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return SAMPLER;
"#line"								glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return LINE;
^"#include"[\t ]+{STR_BLCK}[\t ]*\n	{
									    string tmp(yytext);
									    size_t firstLoc=tmp.find('"')+1;
									    size_t secondLoc=tmp.find('"', firstLoc);
									    glfxlval.strs[0]=tmp.substr(firstLoc, secondLoc-firstLoc);
									    glfxlval.lineno=yylineno-1; // flex has already jumped one line, since \n was eaten
									    return INCLUDE;
									}
"patch"|"centroid"					if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.strs[0]=yytext; return STORAGET;}
"vs"								if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sType=VERTEX_SHADER; return SHADER_TYPE;}
"tc"								if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sType=TESSELATION_CONTROL_SHADER; return SHADER_TYPE;}
"te"								if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sType=TESSELATION_EVALUATION_SHADER; return SHADER_TYPE;}
"gs"								if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sType=GEOMETRY_SHADER; return SHADER_TYPE;}
"fs"								if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sType=FRAGMENT_SHADER; return SHADER_TYPE;}
"cs"								if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sType=COMPUTE_SHADER; return SHADER_TYPE;}

"SetVertexShader"					if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetVertexShader; return SHADER_COMMAND;}
"SetHullShader"						if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetHullShader; return SHADER_COMMAND;}
"SetDomainShader"					if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetDomainShader; return SHADER_COMMAND;}
"SetGeometryShader"					if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetGeometryShader; return SHADER_COMMAND;}
"SetPixelShader"					if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetFragmentShader; return SHADER_COMMAND;}
"SetFragmentShader"					if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetFragmentShader; return SHADER_COMMAND;}
"SetComputeShader"					if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetComputeShader; return SHADER_COMMAND;}

"SetRasterizerState"				if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetRasterizerState; return SHADER_COMMAND;}
"SetDepthStencilState"				if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetDepthStencilState; return SHADER_COMMAND;}
"SetBlendState"						if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.sCommand=SetBlendState; return SHADER_COMMAND;}

{STR_BLCK}							if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.strs[0]=yytext; return QUOTED_STRING;}
{NUM_BLCK}							if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.num=atoi(yytext); glfxlval.strs[0]=yytext; return NUM;}
{FLOAT_BLCK}						if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.fnum=(float)atof(yytext); return FLOAT;}
"in"|"out"							if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return STORAGEQ;}
"gl_FragDepth"						if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return GL_FRAGDEPTH;}
"true"								if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.num=1; return NUM;}
"false"								if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.num=0; return NUM;}
{ID_BLCK}							if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return IDENTIFIER;}
"("									if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {return LP;}
")"									if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {return RP;}
"{"									if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {return LB;}
"}"									if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {return RB;}
"["[\t ]*"]"						if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {return EMPTY_ARRAY_BRACKETS;}
","									if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {return COMMA;}
"="									if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {return EQUALS;}
";"									if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {return SC;}
":"									if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {return COLON;}
\/\/[^\n\\]*(\\+[^\\][^\n\\]*)*\n	if(gLexPassthrough) gEffect->m_sharedCode<<yytext; // Single line comment (with possible continuation)
\/\*[^*]*\*(([^*/][^*]*)*\*)*\/		if(gLexPassthrough) gEffect->m_sharedCode<<yytext; // Multiline comment
[\t\n ]								if(gLexPassthrough) gEffect->m_sharedCode<<yytext;
.									if(gLexPassthrough) gEffect->m_sharedCode<<yytext; else {errLex(yytext);}
%%

void errLex(const char* tok)
{
    ostringstream errMsg;
    
    errMsg<<"0("<<yylineno<<") : error: Unkown token '"<<tok<<'\'';
    throw errMsg.str();
}

string glfxreadblock(unsigned char openChar, unsigned char closeChar)
{
    string str;
    int braceBalance=0;
    unsigned char c;
    bool done=false;
    do {
        c=(unsigned char)yyinput();
        str+=c;
        if(c==0)
		{
            throw "Brace balance error\n";
		}
        else if(c==openChar)
		{
            braceBalance++;
		}
        else if(c==closeChar) {
            braceBalance--;
            if(braceBalance<0)
			{
                throw "Brace balance error\n";
			}
            else if(braceBalance==0)
                done=true;
        }
    } while(!done);
    return str;
}
