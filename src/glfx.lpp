/*
Flex and Bison files have three sections:

the first is sort of "control" information,
the second is the actual token/grammar definitions,
the last is C code to be copied verbatim to the output.
*/
%option yylineno
%option noyywrap
%option stack
%option fast
%option ecs
%option prefix="glfx"
%option outfile="src/glfxScanner.cpp" header-file="src/glfxScanner.h"

%{
    #ifdef _MSC_VER
		// MS's C++ compiler is more strict than gcc
		// No unistd.h
		#define YY_NO_UNISTD_H
		// Direct IO functions (read and such)
		#include <io.h>
		// Disable the warning for yywrap
		#pragma warning( disable: 4003 )
		// Disable the warning about deprecated naming of _read and friends
		#pragma warning( disable: 4996 )
    #endif

    #ifdef _M_X64
		// flex is (still) incompatible with x64
		// it makes some casts from pointers to integers (pointer casts seem to be fixed in the latest version) and from size_t to integers
		// it should work though, nothing too serious
		#pragma warning( disable:4267 )
		#pragma warning( disable:4244 )
    #endif

    #include <iostream>
    #include <string>
    #include <sstream>

    #include "glfxParser.h"
    #include "glfxClasses.h"
    #include "glfxEffect.h"

    // tokens from parser generator
    #include "glfxLALRParser.hpp"

    static void errLex(const char* tok);

    using namespace std;
    using namespace glfxParser;
	static int brace=0;
	#pragma optimize("",off)
	void glfxWrite(const char *txt)
	{
		gEffect->m_sharedCode<<txt;
	}
%}

%x IN_SHADER IN_DEFINE IN_SHADER_COMPILE IN_RENDER_STATE IN_STRUCT

ID_BLCK [a-zA-Z\.][a-zA-Z0-9_\.]*
NUM_BLCK 0|([1-9][0-9]*)
HEX_BLCK 0x[0-9A-Fa-f][0-9A-Fa-f]*
STR_BLCK \"[^"\n]*\"
FLOAT_BLCK [0-9]*((\.[0-9])|([0-9]\.))[0-9]*f?

/* The %% means that we are done with the CONTROL section, and now move onto the token definitions
<INITIAL>"patch"|"centroid"						if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.strs[0]=yytext; return STORAGET;}*/
%%
<INITIAL>"#"define								{
													if(gLexPassthrough)
														glfxWrite(yytext); 
													glfxPushState(IN_DEFINE);
													return DEFINE;
												}
<INITIAL>"[numthreads("{NUM_BLCK}","{NUM_BLCK}","{NUM_BLCK}")]" {
													glfxlval.strs[0]=yytext;
													return CS_LAYOUT;
												}
<IN_DEFINE>[^\n]+								{
													if(gLexPassthrough)
														glfxWrite(yytext); 
													return MACRO_DEFINITION;
												}
<IN_DEFINE>\n									{
													if(gLexPassthrough)
														glfxWrite(yytext); 
													glfxPopState();
													return EOL;
												}
<INITIAL>"layout"								{
													/*layout(local_size_x=u,local_size_y=v,local_size_z=w) in;*/
													glfxlval.lineno=yylineno;
													glfxlval.strs[0]=yytext;
													glfxPushState(IN_SHADER_COMPILE);
													return LAYOUT;
												}
<INITIAL>"struct"								{
													glfxPushState(IN_STRUCT);
													return STRUCT;
												}
<INITIAL>"SV_DispatchThreadID"					glfxlval.strs[0]=yytext;		return INPUT_SEMANTIC;
<INITIAL>"gl_GlobalInvocationID"				glfxlval.strs[0]=yytext;		return INPUT_SEMANTIC;
<INITIAL>"program"								glfxlval.boolean=false;		return PROGRAM;
<INITIAL>"stages"								glfxlval.boolean=true;		return PROGRAM;
<INITIAL>"technique"							glfxlval.boolean=false;		return TECHNIQUE;
<INITIAL>"pass"									glfxlval.boolean=false;		return PASS;
<INITIAL>"group"								glfxlval.boolean=false;		return GROUP;
<INITIAL>"shader"								glfxlval.lineno=yylineno;	glfxlval.strs[0]=yytext;	return SHADER;
<INITIAL>"interface"							glfxlval.lineno=yylineno;	glfxlval.strs[0]=yytext;	return INTERFACE;
<INITIAL>"sampler"								glfxlval.lineno=yylineno;	glfxlval.strs[0]=yytext;	return SAMPLER;
<INITIAL>"profile"								{
													glfxPushState(IN_SHADER_COMPILE);
													return PROFILE;
												}
<INITIAL,IN_SHADER_COMPILE,IN_RENDER_STATE>"#line"	{
														glfxlval.lineno=yylineno;
														glfxlval.strs[0]=yytext;
														return LINE;
													}
<INITIAL>^"#include"[\t ]+{STR_BLCK}[\t ]*\n	{
													string tmp(yytext);
													size_t firstLoc=tmp.find('"')+1;
													size_t secondLoc=tmp.find('"', firstLoc);
													glfxlval.strs[0]=tmp.substr(firstLoc, secondLoc-firstLoc);
													glfxlval.lineno=yylineno-1; // flex has already jumped one line, since \n was eaten
													return INCLUDE;
												}
<INITIAL>"vs"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=VERTEX_SHADER; return SHADER_TYPE;}
<INITIAL>"tc"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=TESSELATION_CONTROL_SHADER; return SHADER_TYPE;}
<INITIAL>"te"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=TESSELATION_EVALUATION_SHADER; return SHADER_TYPE;}
<INITIAL>"gs"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=GEOMETRY_SHADER; return SHADER_TYPE;}
<INITIAL>"fs"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=FRAGMENT_SHADER; return SHADER_TYPE;}
<INITIAL>"cs"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.sType=COMPUTE_SHADER; return SHADER_TYPE;}

<INITIAL>"RasterizerState"						{
													glfxlval.lineno=yylineno;
													renderState=RASTERIZER_STATE;
													glfxPushState(IN_RENDER_STATE);
													return RENDER_STATE_DECL;
												}
<INITIAL>"DepthStencilState"					{
													glfxlval.lineno=yylineno;
													renderState=DEPTHSTENCIL_STATE;
													glfxPushState(IN_RENDER_STATE);
													return RENDER_STATE_DECL;
												}
<INITIAL>"BlendState"							{
													glfxlval.lineno=yylineno;
													renderState=BLEND_STATE;
													glfxPushState(IN_RENDER_STATE);
													return RENDER_STATE_DECL;
												}
<INITIAL>"SamplerState"							{
													glfxlval.lineno=yylineno;
													renderState=SAMPLER_STATE;
													glfxPushState(IN_RENDER_STATE);
													return RENDER_STATE_DECL;
												}
<INITIAL>"SetVertexShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=VERTEX_SHADER; 					
														glfxlval.sCommand=SetVertexShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetHullShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=TESSELATION_CONTROL_SHADER;
														glfxlval.sCommand=SetHullShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetDomainShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=TESSELATION_EVALUATION_SHADER; 	
														glfxlval.sCommand=SetDomainShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetGeometryShader"					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=GEOMETRY_SHADER; 				
														glfxlval.sCommand=SetGeometryShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetPixelShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=FRAGMENT_SHADER; 				
														glfxlval.sCommand=SetFragmentShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetFragmentShader"					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=FRAGMENT_SHADER; 				
														glfxlval.sCommand=SetFragmentShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetComputeShader"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sType=COMPUTE_SHADER;	 				
														glfxlval.sCommand=SetComputeShader;
														glfxPushState(IN_SHADER_COMPILE);
														return SHADER_COMMAND;
													}
												}
<INITIAL>"SetRasterizerState"					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sCommand=SetRasterizerState;
														return SET_RASTERIZER_COMMAND;
													}
												}
<INITIAL>"SetDepthStencilState"					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sCommand=SetDepthStencilState;
														return SET_DEPTH_COMMAND;
													}
												}
<INITIAL>"SetBlendState"						{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.sCommand=SetBlendState;
														return SET_BLEND_COMMAND;
													}
												}

<INITIAL>"VertexShader"							{glfxlval.lineno=yylineno;	glfxlval.sType=VERTEX_SHADER;	glfxPushState(IN_SHADER_COMPILE); return DECL_SHADER;}
<INITIAL>"PixelShader"							{glfxlval.lineno=yylineno;	glfxlval.sType=FRAGMENT_SHADER;	glfxPushState(IN_SHADER_COMPILE); return DECL_SHADER;}
<INITIAL>"FragmentShader"						{glfxlval.lineno=yylineno;	glfxlval.sType=FRAGMENT_SHADER;	glfxPushState(IN_SHADER_COMPILE); return DECL_SHADER;}
<IN_SHADER_COMPILE>"CompileShader"				{
													glfxlval.lineno=yylineno;
													return COMPILE_SHADER;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE,IN_STRUCT>{ID_BLCK}	{
													glfxlval.lineno=yylineno;
													glfxlval.strs[0]=yytext;
													return IDENTIFIER;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE>{NUM_BLCK}	{
													glfxlval.lineno=yylineno;
													glfxlval.num=atoi(yytext);
													glfxlval.strs[0]=yytext;
													return NUM;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE>{FLOAT_BLCK}	{
													glfxlval.lineno=yylineno;
													glfxlval.fnum=(float)atof(yytext);
													return FLOAT;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE>"("			{
													glfxlval.strs[0]=yytext;
													return LP;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE>")"			{
													glfxlval.strs[0]=yytext;
													return RP;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE>"["			{
													glfxlval.strs[0]=yytext;
													return LEFT_SQ;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE>"]"			{
													glfxlval.strs[0]=yytext;
													return RIGHT_SQ;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE>","			{
													glfxlval.strs[0]=yytext;
													return COMMA;
												}
<IN_SHADER_COMPILE,IN_RENDER_STATE>"="			{
													glfxlval.strs[0]=yytext;
													return EQUALS;
												}
<IN_SHADER_COMPILE>";"							{
													glfxlval.strs[0]=yytext;
													glfxPopState();
													return SC;
												}
<IN_RENDER_STATE,IN_STRUCT>";"							{
													glfxlval.strs[0]=yytext;
													if(!brace)
														glfxPopState();
													return SC;
												}
<INITIAL>{STR_BLCK}								{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.strs[0]=yytext;
														return QUOTED_STRING;
													}
												}
<INITIAL>{HEX_BLCK}								{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.unum=strtoul(yytext, NULL, 16);
														glfxlval.strs[0]=yytext;
														return NUM;
													}
												}
<INITIAL>{NUM_BLCK}								{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.num=atoi(yytext);
														glfxlval.strs[0]=yytext;
														return NUM;
													}
												}
<INITIAL>{FLOAT_BLCK}							if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.fnum=(float)atof(yytext); return FLOAT;}
<INITIAL>"in"|"out"								if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return STORAGEQ;}
<INITIAL>"gl_FragDepth"							if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.lineno=yylineno; glfxlval.strs[0]=yytext; return GL_FRAGDEPTH;}
<INITIAL>"true"									if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.num=1; return NUM;}
<INITIAL>"false"								if(gLexPassthrough) glfxWrite(yytext); else {glfxlval.num=0; return NUM;}
<INITIAL>{ID_BLCK}								{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.strs[0]=yytext;
														return IDENTIFIER;
													}
												}
<INITIAL>{ID_BLCK}"::"{ID_BLCK}					{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														glfxlval.lineno=yylineno;
														glfxlval.strs[0]=yytext;
														return IDENTIFIER;
													}
												}
<INITIAL>"("									if(gLexPassthrough) glfxWrite(yytext); else {return LP;}
<INITIAL>")"									if(gLexPassthrough) glfxWrite(yytext); else {return RP;}
<INITIAL>"{"									{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														if(read_shader)
														{
															brace++;
															glfxPushState(IN_SHADER);
														}
														return LB;
													}
												}
<INITIAL>"}"									{
													if(gLexPassthrough)
														glfxWrite(yytext);
													else
													{
														return RB;
													}//"["[\t ]*"]"						if(gLexPassthrough) glfxWrite(yytext); else {return EMPTY_ARRAY_BRACKETS;}
												}
<INITIAL>"["									if(gLexPassthrough) glfxWrite(yytext); else {return LEFT_SQ;}
<INITIAL>"]"									if(gLexPassthrough) glfxWrite(yytext); else {return RIGHT_SQ;}
<INITIAL>","									if(gLexPassthrough) glfxWrite(yytext); else {return COMMA;}
<INITIAL>"="									if(gLexPassthrough) glfxWrite(yytext); else {return EQUALS;}
<INITIAL>";"									if(gLexPassthrough) glfxWrite(yytext); else {return SC;}
<INITIAL>":"									if(gLexPassthrough) glfxWrite(yytext); else {return COLON;}
<IN_STRUCT>":"									return COLON;
<INITIAL,IN_RENDER_STATE>\/\/[^\n\\]*(\\+[^\\][^\n\\]*)*\n		{
													if(gLexPassthrough)
														glfxWrite(yytext); // Single line comment (with possible continuation)
												}
<INITIAL,IN_RENDER_STATE>\/\*[^*]*\*(([^*/][^*]*)*\*)*\/		{
													if(gLexPassthrough)
														glfxWrite(yytext); // Multiline comment
												}
<INITIAL>[\t\n ]								{
													if(gLexPassthrough) glfxWrite(yytext);
												}
<IN_RENDER_STATE>[\t\n ]						{}// Without this line, the yylineno would get out of whack.
<INITIAL>.										if(gLexPassthrough) glfxWrite(yytext); else {errLex(yytext);}
<IN_SHADER,IN_RENDER_STATE,IN_STRUCT>"{"		{
													glfxlval.strs[0]=yytext;
													brace++;
													return LB;
												}
<IN_SHADER>"}"									{
													glfxlval.strs[0]=yytext;
													brace--;
													if(!brace)
													{
														glfxPopState();
														return RB;
													}
													return RB;
												}
<IN_RENDER_STATE,IN_STRUCT>"}"					{
													glfxlval.strs[0]=yytext;
													brace--;
													return RB;
												}
<IN_SHADER>[^\n{}]*\n							{
													glfxlval.strs[0]=yytext;
													return SHADER_LINE;
												}
%%
void glfxPushState(int s)
{
	yy_push_state(s);
}
void glfxPopState()
{
	if(yy_start_stack_ptr<=0)
		glfxerror("Stack underflow");
	else
		yy_pop_state();
}
void glfxPopAllStates()
{
	while(yy_start_stack_ptr>0)
		yy_pop_state();
}
const char *glfxGetStateText()
{
	switch(YYSTATE)
	{
	case IN_SHADER:
		return "shader";
	case IN_DEFINE:
		return "macro definition";
	case IN_SHADER_COMPILE:
		return "shader compile";
	case IN_RENDER_STATE:
		return "render state def";
	default:
		return "default state";
	};
}
void resetGlfxParse()
{
	brace=0;
	glfxset_lineno(1);
	glfxPopAllStates();
}

void errLex(const char* tok)
{
    ostringstream errMsg;
    
    errMsg<<"0("<<yylineno<<") : error: Unkown token '"<<tok<<'\'';
   // throw errMsg.str();
	glfxerror(errMsg.str().c_str());
}

string glfxreadblock(unsigned char openChar, unsigned char closeChar)
{
    string str;
    int braceBalance=0;
    int c;
    bool done=false;
    do {
        c=yyinput();
        if(c<=0)
		{
            throw "Brace balance error\n";
		}
        str+=(unsigned char)c;
		if((unsigned char)c==openChar)
		{
            braceBalance++;
		}
        else if((unsigned char)c==closeChar)
		{
            braceBalance--;
            if(braceBalance<0)
			{
                throw "Brace balance error\n";
			}
            else if(braceBalance==0)
                done=true;
        }
    } while(!done);
    return str;
}
