%name-prefix "glfx"
%output "src/glfxLALRParser.cpp"
%defines "src/glfxLALRParser.hpp"
%{
	//#define YYFPRINTF glfxprintf
	#define YYDEBUG 1
    #include <iostream>
    #include <map>
    #include <string>
    #include <vector>
    #include <sstream>
    
    #include "glfxParser.h"
    #include "glfxClasses.h"

    using namespace std;
    using namespace glfxParser;
    
    #ifdef _MSC_VER
		// MS's C++ compiler is more strict than gcc
    
		// bison related
		// Disable the warning about default being present but no other cases in switch
		#pragma warning( disable:4065 )

		// No unistd.h (for flex)
		#define YY_NO_UNISTD_H
		#define YYERROR_VERBOSE
    #endif
    #include "glfxScanner.h"
    #include "glfxEffect.h"

    static void errSyn(const char *e);
    static void errSem(const string& str, int line=-1);
	RasterizerState buildRasterizerState;
	Struct buildStruct;
	BlendState buildBlendState;
	DepthStencilState buildDepthStencilState;
	SamplerState buildSamplerState;
	static int last_linenumber=0;
	static int current_filenumber=0;
	static int global_linenumber=0;
	std::string currentCsLayout;
	int last_recorded_linenum	=0;
	int global_linenum			=0;
	int filenum					=0;
	#pragma optimize("",off)
	bool is_equal(const string& a, const char * b)
	{
		size_t sz = a.size();
		if (strlen(b) != sz)
			return false;
		for (size_t i = 0; i < sz; ++i)
			if (tolower(a[i]) != tolower(b[i]))
				return false;
		return true;
	}
	bool toBool(const string &str)
	{
		if(is_equal(str,"TRUE"))
			return true;
		else if(is_equal(str,"FALSE"))
			return false;
		else errSem("Expected boolean.");
		return false;
	}
	void WriteLineNumber(std::ostringstream &str,int fileno,int lineno)
	{
		str<<"#line "<<lineno<<" "<<fileno<<endl;
	}
	void WriteLineNumber(std::ostringstream &str,int lineno)
	{
		WriteLineNumber(str,current_filenumber,lineno);//.c_str()<<"\""<<endl;
	}
	static bool write_line_number_next=false;
	static void Skip()
	{
		write_line_number_next=true;
	}
	static string GetLayoutForTemplateType(string s)
	{
		if(s==string("vec4"))
		{
			return "";
		}
		return "";
	}
%}

%token WHITESPACE UNIFORM SHADER PROGRAM INTERFACE IDENTIFIER STORAGEQ GL_FRAGDEPTH SHADER_COMMAND SET_RASTERIZER_COMMAND SET_DEPTH_COMMAND SET_BLEND_COMMAND
%token INPUT_SEMANTIC NUM INCLUDE SAMPLER FLOAT
%token LAYOUT LINE TECHNIQUE PASS GROUP RENDER_STATE_DECL QUOTED_STRING SHADER_LINE SHADER_TYPE COMPILE_SHADER STRUCT
%token DEFINE MACRO_DEFINITION EOL DECL_SHADER PROFILE CS_LAYOUT 
%token RW_TEXTURE3D_FLOAT4 TEXTURE2DMS IMAGE3D KNOWN_TYPE
%token RETURN BREAK CONTINUE DO FOR GOTO IF WHILE ELSE 
%token TIMES_EQUALS OVER_EQUALS PERCENT_EQUALS PLUS_EQUALS MINUS_EQUALS LEFT_SHIFT_EQUALS RIGHT_SHIFT_EQUALS AND_EQUALS XOR_EQUALS OR_EQUALS
%token AND OR LESS_EQ GRTR_EQ LEFT_SHIFT RIGHT_SHIFT PLUS_PLUS MINUS_MINUS EQ_EQ NOT_EQ


%%

prog : prog tok
    | { // Initialization code
	    gEffect->m_sharedCode.str("");    // clear the stream
	    gLexPassthrough=true;
	};
	tok : INTERFACE lex_fx IDENTIFIER read_block ';' lex_passthrough
	{
		gEffect->m_interfaces[$3.strs[0]]=Effect::InterfaceDcl($4.strs[0], $1.lineno);
	}
	| EOL
	{
	}
	| line_statement
	{
	}
	| UNIFORM texture_type optional_templateval IDENTIFIER ';'
	{
		bool compute_only=($2.strs[0]==string("image3D"));

		ostringstream decl;
		if(compute_only)
			decl<<"#ifdef USE_GL_COMPUTE_SHADER\n";
		decl<<GetLayoutForTemplateType($3.strs[0])<<" uniform "<<$2.strs[0]<<" "<<$4.strs[0]<<";";
		if(compute_only)
			decl<<"\n#endif\n";
		gEffect->m_sharedCode<<decl.str();
	}
	| UNIFORM IDENTIFIER IDENTIFIER ';'
	{
		ostringstream decl;
		decl<<$1.strs[0]<<" "<<$2.strs[0]<<" "<<$3.strs[0]<<";";
		gEffect->m_sharedCode<<decl.str();
	}
	| CS_LAYOUT
	{
		currentCsLayout=$1.strs[0];
	}
	| LAYOUT cs_layout_spec IDENTIFIER ';'
	{
		currentCsLayout="";
		currentCsLayout+=$1.strs[0];
		currentCsLayout+=$2.strs[0];
		currentCsLayout+=$3.strs[0];
		currentCsLayout+=$4.strs[0];
	}
	| LAYOUT normal_layout_spec
	{
		string str=$1.strs[0]+" "+$2.strs[0];
		glfxWrite(str.c_str());
		glfxPopState();
	}
	| RW_TEXTURE3D_FLOAT4 IDENTIFIER ';'
	{
		string str="layout(rgba32f) uniform image3D ";
		str+=$2.strs[0]+";";
		glfxWrite(str.c_str());
	}
	| RW_TEXTURE3D_FLOAT4 IDENTIFIER ','
	{
		string str="layout(rgba32f) image3D ";
		str+=$2.strs[0]+",";
		glfxWrite(str.c_str());
	}
	| DEFINE MACRO_DEFINITION EOL
	{
	}
	| STRUCT IDENTIFIER '{' struct_members '}' ';'
	{
		Struct *rs					=new Struct;
		*rs							=buildStruct;
		string name					=$2.strs[0];
		gEffect->m_structs[name]	=rs;
		// Set to default:
		buildStruct					=Struct();
		gEffect->m_sharedCode<<"struct "<<$2.strs[0]<<"\n{\n";
		for(int i=0;i<(int)rs->m_structMembers.size();i++)
		{
			const StructMember &m=rs->m_structMembers[i];
			gEffect->m_sharedCode<<m.type<<" "<<m.name<<";\n";
		
		}
		WriteLineNumber(gEffect->m_sharedCode,current_filenumber,$6.lineno+last_linenumber-global_linenumber);
		gEffect->m_sharedCode<<"};";
	}
	| RENDER_STATE_DECL IDENTIFIER optional_render_state_list ';'
	{
		$$.lineno		=$4.lineno;
		RenderState t=renderState;
		string name=$2.strs[0];
		if(t==RASTERIZER_STATE)
		{
			RasterizerState *rs=new RasterizerState;
			*rs=buildRasterizerState;
			gEffect->m_rasterizerStates[name]=rs;
			// Set to default:
			buildRasterizerState=RasterizerState();
		}
		if(t==BLEND_STATE)
		{
			BlendState *bs=new BlendState;
			*bs= buildBlendState;
			gEffect->m_blendStates[name]=bs;
			// Set to default:
			buildBlendState=BlendState();
		}
		if(t==DEPTHSTENCIL_STATE)
		{
			DepthStencilState *ds=new DepthStencilState;
			*ds=buildDepthStencilState;
			gEffect->m_depthStencilStates[name]=ds;
			// Set to default:
			buildDepthStencilState=DepthStencilState();
		}
		if(t==SAMPLER_STATE)
		{
			SamplerState *ss=new SamplerState;
			*ss=buildSamplerState;
			gEffect->m_samplerStates[name]=ss;
			// Set to default:
			buildSamplerState=SamplerState();
		}
		int true_linenumber=$4.lineno+(last_linenumber-global_linenumber);
	//	WriteLineNumber(true_linenumber);
	}
	| PROFILE IDENTIFIER '(' NUM ')' ';'
	{
		string profileName		=$2.strs[0];
		int profileNum			=$4.num;
		if(gEffect->m_profileToVersion.find(profileName)!=gEffect->m_profileToVersion.end())
		{
			glfxWarning("redefining profile ");
		}
		gEffect->m_profileToVersion[profileName]=profileNum;
	}
	| DECL_SHADER IDENTIFIER '=' shader_compile ';'
	{
		// We here declare that a named shader should be compiled with the specified profile (e.g. GLSL 4.30)
		// and assign a variable name to the shader/profile combination. Later on, in pass definitions,
		// we can assign the shader to one or more passes.
		string compiledShaderName		=$2.strs[0];
		CompiledShader *cs				=gEffect->m_compiledShaders[$4.strs[0]];
		CompiledShader *compiledShader	=NULL;
		CompiledShaderMap::iterator i	=gEffect->m_compiledShaders.find(compiledShaderName);
		if(i!=gEffect->m_compiledShaders.end())
		{
			delete i->second;
			// TODO: Warn here about double-compiling a shader.
			glfxWarning("double-compiling shader ");
		}
		gEffect->m_compiledShaders[compiledShaderName]=compiledShader=cs;
	}
	| LAYOUT lex_fx layout_params lex_passthrough
	{
		currentCsLayout="";
		currentCsLayout+=$1.strs[0];
		currentCsLayout+=$3.strs[0];
	}
	// GL-style, e.g. shader VSMain(in type param,out type param) function_content
    | shader_and_layout IDENTIFIER IDENTIFIER '(' param_declaration_list ')' optional_return_semantic function_content lex_passthrough
	{
		std::string shaderName		=$3.strs[0];
		std::string returnType		=$2.strs[0];
		std::string shaderContent	=$8.strs[0];
		ostringstream shaderCode;
		ostringstream extraDeclarations;
		int main_linenumber=$1.lineno+(last_linenumber-global_linenumber);
		int content_linenumber=$8.lineno+(last_linenumber-global_linenumber);
		// Add shader parameters
		for(vector<YYSTYPE::variable>::const_iterator it=$5.vars->begin();it!=$5.vars->end();++it)
		{
			string structInstanceName=it->identifier;
			string type(it->type);
			map<string,Struct*>::const_iterator u=gEffect->m_structs.find(type);
			map<string, Effect::InterfaceDcl>::const_iterator varType=gEffect->m_interfaces.find(type);
			int lineno;
			if(u!=gEffect->m_structs.end())
			{
				extraDeclarations<<type<<" "<<structInstanceName<<";\n";
				const Struct *s=u->second;
				for(int i=0;i<(int)s->m_structMembers.size();i++)
				{
					const StructMember &m=s->m_structMembers[i];
					string sem=m.name;
					if(m.semantic.length())
						sem=m.semantic;
					//shaderCode<<"#line "<<main_linenumber<<" "<<current_filenumber<<endl;
					shaderCode<<it->storage<<' '<<m.type<<' '<<sem<<"_;"<<endl;
					extraDeclarations<<structInstanceName<<"."<<m.name<<"="<<sem<<"_;\n";
				}
				continue;
			}
			else if(varType!=gEffect->m_interfaces.end())
			{
				type+=varType->second.id;
				lineno=varType->second.atLine;
			}
			else
				lineno=$1.lineno;
			if(it->semantic.length()>0)
			{
				shaderCode<<"#define "<<it->identifier<<" "<<it->semantic<<endl;
			}
			else
			{
			// First put #line in to make sure that all our definitions produce correct-looking warnings/errors.
				shaderCode<<"#line "<<main_linenumber<<" "<<current_filenumber<<endl;
				shaderCode<<it->storage<<' '<<type<<' '<<it->identifier<<';'<<endl;
			}
		}
		delete $5.vars;
		// Add definition and code
		shaderCode<<"#line "<<main_linenumber<<" "<<current_filenumber<<endl;
		shaderCode<<"void main()\n{\n";
		if(extraDeclarations.str().length())
			shaderCode<<extraDeclarations.str()<<"\n";
		shaderCode<<"#line "<<content_linenumber<<" "<<current_filenumber<<endl;
		shaderCode<<shaderContent<<"\n}\n";
		gEffect->m_shaderLayouts[shaderName]	=currentCsLayout;
		gEffect->m_shaders[shaderName]			=shaderCode.str();
		// now we must put a #line directive in the shared code, because we've just snipped out a bunch of what was there:
		
		gEffect->m_sharedCode<<"#line "<<(glfxget_lineno()+(last_linenumber-global_linenumber))<<" "<<current_filenumber<<endl;
	}
    | PROGRAM lex_fx IDENTIFIER '{' prog_def '}' lex_passthrough
	{
		$5.prog->m_separable=$1.boolean;
		gEffect->m_programs[$3.strs[0]]=$5.prog;
	}
	| TECHNIQUE lex_fx IDENTIFIER '{' tech_def '}' lex_passthrough
	{
		gEffect->m_techniques[$3.strs[0]] = $5.tech;
	};
	line_statement: LINE lex_fx NUM NUM lex_passthrough
	{
		last_linenumber		=$3.num;
		current_filenumber	=$4.num;
		global_linenumber	=$1.lineno+1;// the line AFTER the #line directve.
		WriteLineNumber(gEffect->m_sharedCode,current_filenumber,last_linenumber);
	}
	ignore_line_statement: LINE NUM NUM
	{
		last_linenumber		=$2.num;
		current_filenumber	=$3.num;
		global_linenumber	=$1.lineno;
	}
	shader_and_layout: SHADER shader_fx
	{
		$$.strs[0]	=$1.strs[0];
		$$.lineno	=$1.lineno;
	};
	texture_type: TEXTURE2DMS|IMAGE3D
	{
		$$.strs[0]	=$1.strs[0];
		$$.num		=$1.num;
	};
	optional_templateval: '<' IDENTIFIER '>'
	{
		$$.strs[0]	=$2.strs[0];
		$$.num		=1;
	}
	|
	{
		$$.strs[0]	="";
		$$.num		=0;
	}
layout_params:'(' NUM ',' NUM ',' NUM ')'
{
	std::string ret="(";
	ret+=$2.strs[0];
	ret+=",";
	ret+=$4.strs[0];
	ret+=",";
	ret+=$6.strs[0];
	ret+=")";
	$$.strs[0]=ret;
};
cs_layout_spec: '(' cs_layout ')'
		  {
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		  };
normal_layout_spec: '(' tx_layout ')'
		 {
				$$.layoutType=NORMAL_LAYOUT_TYPE;
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		 };
tx_layout: tx_layout ',' layout_s
				{
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
					| layout_s
				{
				$$.strs[0]=$1.strs[0];
				};
layout_s: layout_el
	   {
				$$.strs[0]=$1.strs[0];
	   }
		   | IDENTIFIER
	   {
				$$.strs[0]=$1.strs[0];
	   };
cs_layout: layout_el ',' layout_el ',' layout_el
		  {
				$$.layoutType=CS_LAYOUT_TYPE;
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
		  };
layout_el: IDENTIFIER '=' layout_def
		   {
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		   };

layout_def: IDENTIFIER
		   {
				$$.strs[0]=$1.strs[0];
		   }
		   | NUM
		   {
				$$.strs[0]=$1.strs[0];
		   }
lex_fx :
{ /* Switch lex to fx scanning */
	read_shader=false;
    gLexPassthrough=false;
};

shader_fx :
{
	read_shader=true;
    gLexPassthrough=false;
};

lex_passthrough :
{ /* Switch lex to passthrough mode */
    gLexPassthrough=true;
};

function_content : '{' statement_list '}' { /* Read next block */
    $$.strs[0]=$2.strs[0];
	// string 1 is the return value, if present.
	$$.strs[1]= $2.strs[1];
    $$.lineno= $2.lineno;
};

read_block : { /* Read next block */
    $$.strs[0]= glfxreadblock('{', '}');
    $$.lineno= glfxget_lineno();
};

optional_return_semantic: ':' IDENTIFIER
 {
 }
 |
 {
 }
param_declaration_list : param_declaration_list ',' param_declaration
	{
		$$.vars=$1.vars;

		YYSTYPE::variable var;
		var.storage=$3.strs[0];
		var.type=$3.strs[1];
		var.identifier=$3.strs[2];
		var.semantic=$3.strs[4];
    
		$$.vars->push_back(var);
	}
    | param_declaration
	{
		YYSTYPE::variable var;
		var.storage=$1.strs[0];
		var.type=$1.strs[1];
		var.identifier=$1.strs[2];
		var.semantic=$1.strs[4];
    
		$$.vars = new vector<YYSTYPE::variable>;
		$$.vars->push_back(var);
	}
    |
	{
		$$.vars = new vector<YYSTYPE::variable>;
	};

param_declaration : param opt_sq location
{
    ostringstream prepend;
	string semantic;
    switch($3.rType)
	{
    case REGISTER_INT:
        prepend<<"layout(location="<<$3.num<<") ";
        break;
    case REGISTER_NAME:
        prepend<<"layout(location="<<$3.strs[0]<<") ";
        break;
    case SEMANTIC:
		semantic=$3.strs[0];
        break;
    }
    prepend<<$1.strs[0];

	string storage	=prepend.str();
	string type		=$1.strs[1];
	string id		=$1.strs[2]+$2.strs[0];

    $$.strs[0]=storage;
    $$.strs[1]=type;
    $$.strs[2]=id;

    $$.strs[3]=$2.strs[0];
    $$.strs[3]+=$3.strs[0];
    $$.strs[4]=semantic;
};

opt_sq: '[' ']'
				{
					$$.strs[0]="[]";
				}
				|
				{
					$$.strs[0]="";
				};

param : opt_storage IDENTIFIER IDENTIFIER
	{
		string storage	=$1.strs[0];
		string type		=$2.strs[0];
		string id		=$3.strs[0];
		$$.strs[0]		= storage	;
		$$.strs[1]		= type		;
		$$.strs[2]		= id		;
	};
opt_storage : STORAGEQ
	{
		$$.strs[0]=$1.strs[0];
	}
	|
	{
		$$.strs[0]="";
	}
location : ':' NUM
	{
		$$.num=$2.num;
		$$.rType=REGISTER_INT;
	}
    | ':' INPUT_SEMANTIC
	{
		$$.strs[0]=$2.strs[0];
		$$.rType=SEMANTIC;
	}
    | ':' IDENTIFIER
	{
		$$.strs[0]=$2.strs[0];
		$$.rType=REGISTER_NAME;
	}
    |
	{
		$$.rType=REGISTER_NONE;
	}
;

tech_def : pass_list
{
	Technique *t = new Technique(*($1.passes));
	$$.tech = t;
	delete $1.passes;
};

pass_list: pass_list pass_def
{
	$$.passes = $1.passes;
	string name = $2.strs[0];
	Program *p = $2.prog;
	if (p)
	{
		(*$$.passes)[name] = *(p);
	}
	delete $2.prog;
}
| pass_def
{
	map < string, Program > *m=new map < string, Program >;
	$$.passes = m;
	string name = $1.strs[0];
	Program *p = $1.prog;
	if (p)
	{
		Program &newp = (*m)[name];
		newp= *p;
	}
	delete p;
};

pass_def: PASS IDENTIFIER '{' prog_def '}'
{
	$4.prog->m_separable = $1.boolean;
	$$.prog = $4.prog;
	$$.strs[0] = $2.strs[0];
}

prog_def : shaders_list
{
    $$.prog = new Program(*($1.shaders));
    delete $1.shaders;
};

shaders_list : shaders_list shader_def
	{
		map<ShaderType, Program::Shader>* map1=$1.shaders;
		ShaderType sType	=$2.sType;
		string src			=$2.strs[0];
		string name			=$2.strs[1];
		(*map1)[sType].src	=src;
		(*map1)[sType].name	=name;
		$$.shaders			=map1;
	}
	| shader_def
	{
		map<ShaderType, Program::Shader>* map1=new map<ShaderType, Program::Shader>();
		string src			=$1.strs[0];
		string name			=$1.strs[1];
		ShaderType sType	=$1.sType;
		$$.strs[0]			=src;
		$$.strs[1]			=name;
		$$.sType			=sType;
		(*map1)[sType].src	=src;
		(*map1)[sType].name	=name;
		$$.shaders=map1;
	}
	| shaders_list shader_fn
	{
		map<ShaderType, Program::Shader>* map1=$1.shaders;
		$$.shaders=$1.shaders;
		$$.strs[0]	="";
		$$.strs[1]	="";
		$$.sType	=(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
	}
	| shader_fn
	{
		map<ShaderType, Program::Shader>* map1=new map<ShaderType, Program::Shader>();
		$$.shaders=map1;
		$$.strs[0]	="";
		$$.strs[1]	="";
		$$.sType	=(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
	};
vec4: IDENTIFIER '(' FLOAT ',' FLOAT ',' FLOAT ',' FLOAT ')'
	  {
		  $$.strs[0]=$1.strs[0]+"(";
		  $$.strs[0]+=$3.strs[0]+",";
		  $$.strs[0]+=$5.strs[0]+",";
		  $$.strs[0]+=$7.strs[0]+",";
		  $$.strs[0]+=$9.strs[0]+")";
	  };
	
shader_fn : SET_RASTERIZER_COMMAND '(' IDENTIFIER ')' ';'
			 {
				 string rast_name=$3.strs[0];
			 }
			 | SET_DEPTH_COMMAND '(' IDENTIFIER ',' NUM ')' ';'
			 {
				 string depth_name=$3.strs[0];
				 int index=$5.num;
			 }
			 | SET_BLEND_COMMAND '(' IDENTIFIER ',' vec4 ',' NUM ')' ';'
			 {
				 string blend_name=$3.strs[0];
				 string vec4text=$5.strs[0];
				 unsigned mask=$7.unum;
			 };

shader_def : shader_lvalue '=' shader_rvalue ';'	// Something like vs(430) = VS_Main();
			{
				$$.strs[1]="";
				$$.strs[0]="";
				$$.sType	=(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
				glfxParser::ShaderType shaderType=$1.sType;
				glfxParser::ShaderCommand shaderCommand=$1.sCommand;
				if(shaderType<NUM_OF_SHADER_TYPES&&$3.num>0)
				{
					// Assemble the shader
					ostringstream theShader;
					theShader<<"#version "<<$1.num<<endl;
					theShader<<$3.strs[1];
					// RVK: Must do this because layout(u,v,w) causes problems for non-compute shaders in some compilers:
					if(shaderType==COMPUTE_SHADER)
						theShader<<"#define USE_GL_COMPUTE_SHADER 1"<<endl;
					string shaderName=($3.strs[0]);
					if(_stricmp(shaderName.c_str(),"NULL")!=0)
					{
						theShader<<gEffect->m_sharedCode.str();
						map<string, string>::const_iterator it=gEffect->m_shaders.find(shaderName);
						if(it==gEffect->m_shaders.end())
						{
							int ylineno=$3.lineno;
							int true_linenumber=ylineno+(last_linenumber-global_linenumber);
							ostringstream errMsg;
							errMsg<<"Unable to find referenced shader \""<<shaderName<<'\"';
							errSem(errMsg.str(), true_linenumber);
						}
						else
						{
							if(shaderType==COMPUTE_SHADER)
								theShader<<gEffect->m_shaderLayouts[shaderName]<<"\n";
						// Currently in case of error it never returns (throw)
						// TODO: Handle continuation in case of error
							theShader<<it->second;
						}
					}
					$$.strs[1]=shaderName;
					$$.strs[0]=theShader.str();
				}
				else if(shaderCommand<NumShaderCommands)
				{
					$$.strs[0]=$1.strs[1];
					$$.strs[1]=$1.strs[0];
				}
				$$.sType=$1.sType;
			}
			// For example: SetVertexShader(vs_main);
			| SHADER_COMMAND '(' shader_compile ')' ';'
			{
				$$.strs[1]="";
				$$.strs[0]="";
				$$.sType	=(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
				// the shader_variable is something like vs_main, for which we have a compile command like:
				//												VertexShader vs_layers=CompileShader(430,VS_Layers());
				// i.e. it's a combination of shadertype, profile, and function name.
				// so these are stored in gEffect->m_compiledSHaders.
				string compiledShaderName=$3.strs[0];
				CompiledShaderMap::iterator i=gEffect->m_compiledShaders.find(compiledShaderName);
				if(i==gEffect->m_compiledShaders.end())
				{
					if(_stricmp(compiledShaderName.c_str(),"NULL")==0)
					{
					}
					else
					{
						ostringstream errMsg;
						errMsg<<"Unable to find compiled shader \""<<compiledShaderName<<'\"';
						errSem(errMsg.str(), $3.lineno);
					}
				}
				else
				{
					CompiledShader *compiledShader	=i->second;
					$$.num							=compiledShader->version;
					$$.sCommand						=$1.sCommand;
					$$.sType						=$1.sType;
					ostringstream theShader;
					theShader << "#version " << compiledShader->version << endl;
					glfxParser::ShaderCommand shaderCommand=$1.sCommand;
					if(shaderCommand==COMPUTE_SHADER)
						theShader<<"#define USE_GL_COMPUTE_SHADER 1"<<endl;
					if(shaderCommand<NumShaderCommands)
					{
						string shaderName=compiledShader->m_functionName;
						if(_stricmp(shaderName.c_str(),"NULL")!=0)
						{
							theShader<<gEffect->m_sharedCode.str();
							map<string, string>::const_iterator it=gEffect->m_shaders.find(shaderName);
							if(it==gEffect->m_shaders.end())
							{
								ostringstream errMsg;
								errMsg<<"Unable to find referenced shader \""<<shaderName<<'\"';
								errSem(errMsg.str(), $3.lineno);
							}
							else
							{
								if(shaderCommand==COMPUTE_SHADER)
									theShader<<gEffect->m_shaderLayouts[shaderName]<<"\n";
								// Currently in case of error it never returns (throw)
								// TODO: Handle continuation in case of error
									theShader<<it->second;
							}
						}
						$$.strs[1]=shaderName;
						$$.strs[0]=theShader.str();
					}
				}
			};
		shader_compile: IDENTIFIER
		{
			string compiledShaderName	=$1.strs[0];
			$$.strs[0]					=compiledShaderName;
			$$.num						=0;
			$$.lineno					=$1.lineno;
		}
		| COMPILE_SHADER '(' IDENTIFIER ',' IDENTIFIER '(' ')' ')' 
		{
			$$.lineno					=$5.lineno;
			string profileName								=$3.strs[0];
			ProfileMap::iterator i							=gEffect->m_profileToVersion.find(profileName);
			int version_num=0;
			if(i==gEffect->m_profileToVersion.end())
			{
				ostringstream msg;
				msg<<"Profile not found"<<profileName<<endl;
				errSem(msg.str().c_str());
			}
			else
				version_num=i->second;
			stringstream ss;
			ss << $5.strs[0]<<"Compiled"<<version_num;
			string compiledShaderName						=ss.str();
			$$.strs[0]										=compiledShaderName;

			CompiledShader *compiledShader	=gEffect->m_compiledShaders[compiledShaderName];

			gEffect->m_compiledShaders[compiledShaderName]	=compiledShader=new CompiledShader;
			compiledShader->m_functionName					=$5.strs[0];
			compiledShader->shaderType						=$1.sType;
			compiledShader->version							=$$.num=version_num;
		};
shader_lvalue : SHADER_TYPE '(' NUM ')'
				{
					$$.num	=$3.num;
					$$.sType=$1.sType;
				};
/*shader_variable:NUM ',' IDENTIFIER
				{
					$$.strs[0]=$3.strs[0];
					$$.num=$1.num;
					$$.lineno=$3.lineno;
				};*/
shader_rvalue : IDENTIFIER '(' ')' shader_layout
				{
					$$.lineno=$1.lineno;
					$$.strs[0]=$1.strs[0];
					$$.strs[1]=$4.strs[0];
				}
				|
				{
					$$.num=0;
				};
shader_layout : ':' shader_layout_list
				{
					$$.strs[0]=$2.strs[0];
				}
				|
				{
					$$.strs[0]="";
				};

shader_layout_list : shader_layout_list ',' layout
				{
					$$.strs[0]=$1.strs[0];
					$$.strs[0]+=$3.strs[0];
				}
				| layout
				{
					$$.strs[0]=$1.strs[0];
				};
statement_list: statement_list statement
				{
					$$.strs[0]	=$1.strs[0];
					$$.strs[0]	+=$2.strs[0];
					$$.strs[1]	=$1.strs[1]+$2.strs[1];
				}
				|
				statement
				{
					$$.strs[0]	=$1.strs[0];
					$$.strs[1]	=$1.strs[1];
				}
				|
				{
					$$.strs[0]	="";
					$$.strs[1]	="";
				}
line_statement_in_shader: LINE NUM NUM 
	{
		last_linenumber		=$2.num;
		current_filenumber	=$3.num;
		global_linenumber	=$1.lineno+1;
		$$.strs[0]			=$1.strs[0]+" ";
		$$.strs[0]			+=$2.strs[0]+" ";
		$$.strs[0]			+=$3.strs[0];
		$$.strs[0]			+='\n';
	}
		/*
		THE FOLLOWING IS BASED ON THE K&R BNF for C:
		*/
declaration	: type_spec init_declarator_list
		{
			$$.strs[0]=$1.strs[0]+" ";
			$$.strs[0]+=$2.strs[0];
		}
init_declarator_list	: init_declarator
		{
			$$.strs[0]=$1.strs[0];
		}
			| init_declarator_list ',' init_declarator
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
init_declarator		: declarator
		{
			$$.strs[0]=$1.strs[0];
		}
		| declarator '=' initializer
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
declarator: IDENTIFIER
		{
			$$.strs[0]=$1.strs[0];
		}
		| '(' declarator ')'
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
		| declarator '[' NUM ']'
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0];
		}
			| declarator '['		']'
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
			| declarator '('		')'
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
statement:  expression ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0];
					$$.lineno=$1.lineno;
				}
			   |  ';'
				{
					$$.strs[0]=$1.strs[0];
				}
			| declaration ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0];
				}
			| compound_statement
				{
					$$.strs[0]=$1.strs[0];
				}
			| IF '(' expression ')' statement
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
				}
			| IF '(' expression ')' statement ELSE statement
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0]+$7.strs[0];
				}
			| WHILE '(' expression ')' statement
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
				}
			| DO statement WHILE '(' expression ')' ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0]+$7.strs[0];
				}
			| FOR '(' for_init_statement ';' optional_expression ';' optional_expression ')' statement
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0]+$7.strs[0]+$8.strs[0];
				}
			| GOTO IDENTIFIER ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
			| CONTINUE ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0];
				}
			| BREAK ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0];
				}
			| RETURN optional_expression ';'
			{
				$$.strs[0]="";
				$$.strs[1]=$2.strs[0];
				$$.lineno=$1.lineno;
			}
			| line_statement_in_shader
			{
				$$.strs[0]=$1.strs[0];
				$$.lineno=$1.lineno;
			}
for_init_statement: expression
			{
				$$.strs[0]=$1.strs[0];
			}
			| declaration
			{
				$$.strs[0]=$1.strs[0];
			}
			|
			{}

optional_expression: expression
			{
				$$.strs[0]=$1.strs[0];
			}
			|
			{
				$$.strs[0]="";
			}
/* multiple statements in braces*/
compound_statement	: '{' statement_list '}'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}

expression: assignment_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| expression ',' assignment_exp
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
assignment_exp: conditional_exp
		{
			$$.strs[0]=$1.strs[0];
		}
		| unary_exp assignment_operator assignment_exp
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
assignment_operator: '='	
				{
					$$.strs[0]=$1.strs[0];
				}
				| TIMES_EQUALS
							| OVER_EQUALS
							| PERCENT_EQUALS
							| PLUS_EQUALS
							| MINUS_EQUALS
							| LEFT_SHIFT_EQUALS
							| RIGHT_SHIFT_EQUALS
							| AND_EQUALS
							| XOR_EQUALS
							| OR_EQUALS
	{
		$$.strs[0]=$1.strs[0];
	}
	conditional_exp		: logical_or_exp
	{
		$$.strs[0]=$1.strs[0];
	}
| logical_or_exp '?' expression ':' conditional_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
	}
;
logical_or_exp: logical_and_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| logical_or_exp OR logical_and_exp
				{
					$$.strs[0]=$1.strs[0];
				}
logical_and_exp: inclusive_or_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| logical_and_exp AND inclusive_or_exp
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
inclusive_or_exp	: exclusive_or_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| inclusive_or_exp '|' exclusive_or_exp
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
exclusive_or_exp	: and_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| exclusive_or_exp '^' and_exp
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
and_exp			: equality_exp
{
	$$.strs[0]=$1.strs[0];
}
			| and_exp '&' equality_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			;
equality_exp		: relational_exp
{
	$$.strs[0]=$1.strs[0];
}
			| equality_exp EQ_EQ relational_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| equality_exp NOT_EQ relational_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
relational_exp		: shift_expression
{
	$$.strs[0]=$1.strs[0];
}
			| relational_exp '<' shift_expression
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| relational_exp '>' shift_expression
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| relational_exp LESS_EQ shift_expression
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| relational_exp GRTR_EQ shift_expression
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
shift_expression	: additive_exp
{
	$$.strs[0]=$1.strs[0];
}
			| shift_expression LEFT_SHIFT additive_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| shift_expression RIGHT_SHIFT additive_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
additive_exp		: mult_exp
{
	$$.strs[0]=$1.strs[0];
}
			| additive_exp '+' mult_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| additive_exp '-' mult_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
mult_exp		: cast_exp
{
	$$.strs[0]=$1.strs[0];
}
			| mult_exp '*' cast_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| mult_exp '/' cast_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| mult_exp '%' cast_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
cast_exp		: unary_exp
{
	$$.strs[0]=$1.strs[0];
}
unary_exp		: postfix_exp
{
	$$.strs[0]=$1.strs[0];
}
			| PLUS_PLUS unary_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0];
}
			| MINUS_MINUS unary_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0];
}
			| unary_operator cast_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0];
}
unary_operator		: '&' | '*' | '+' | '-' | '~' | '!'
{
	$$.strs[0]=$1.strs[0];
}
postfix_exp		: primary_exp
					{
						$$.strs[0]=$1.strs[0];
					}
					| postfix_exp '[' expression ']'
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0];
					}
					| postfix_exp '(' argument_exp_list ')'
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0];
					}
					| postfix_exp '('			')'
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
					}
					| postfix_exp '.' IDENTIFIER
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
					}
					| postfix_exp PLUS_PLUS
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0];
					}
					| postfix_exp MINUS_MINUS
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0];
					}
argument_exp_list	: argument_exp_list ',' assignment_exp
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
					}
					| assignment_exp
					{
						$$.strs[0]=$1.strs[0];
					}
initializer		: assignment_exp
				{
					string assignment_exp = $1.strs[0];
					$$.strs[0]=$1.strs[0];
				}
			| '{' initializer_list '}'
				{
					vector<string> children = $$.children;
					children = $2.children;
					string initlist = $1.strs[0] + $2.strs[0] + $3.strs[0];
					$$.strs[0] = initlist;
				}
			| '{' initializer_list ',' '}'
			{
					vector<string> children = $$.children;
					children = $2.children;
					string initlist = $1.strs[0] + $2.strs[0] + $3.strs[0] + $4.strs[0];
					$$.strs[0] = initlist;
				}
initializer_list: initializer
				{
					$$.strs[0]=$1.strs[0];
				}
			| initializer_list ',' initializer
				{
					vector<string> children = $$.children;
					children = $1.children;
					children.push_back($3);
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
primary_exp	: IDENTIFIER
				{
					$$.strs[0]=$1.strs[0];
				}
			| const
				{
					$$.strs[0]=$1.strs[0];
				}
			| '(' expression ')'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
const		: NUM
				{
					$$.strs[0]=$1.strs[0];
				}
			| FLOAT
				{
					$$.strs[0]=$1.strs[0];
				}
layout : STORAGEQ read_parenthesis
	{
		ostringstream layoutDef;
		//layoutDef<<"#line "<<$1.lineno<<endl;
		layoutDef<<"layout"<<$2.strs[0]<<' '<<$1.strs[0]<<';'<<endl;
		$$.strs[0]=layoutDef.str();
	};

layout : GL_FRAGDEPTH read_parenthesis
	{
		ostringstream layoutDef;
		//layoutDef<<"#line "<<$1.lineno<<endl;
		layoutDef<<"layout"<<$2.strs[0]<<' '<<"out float "<<$1.strs[0]<<';'<<endl;
		$$.strs[0]=layoutDef.str();
	};

read_parenthesis :
	{ /* read parenthesis */
		$$.strs[0]=glfxreadblock('(', ')');
	};
struct_member : IDENTIFIER IDENTIFIER optional_semantic ';'
					   {
							$$.lineno		=$3.lineno;
							string name		=$2.strs[0];
							string type		=$1.strs[0];
							string sem		=$3.strs[0];
							StructMember s;
							s.type		=type;
							s.semantic	=sem;
							s.name		=name;
							buildStruct.m_structMembers.push_back(s);
					}
optional_semantic: ':' IDENTIFIER
					{
						$$.strs[0]		=$2.strs[0];
					}
					|
					{
						$$.strs[0]="";
					}
struct_members: struct_members struct_member
					{
						$$.lineno		=$2.lineno;
					}
					|
					struct_member
					{
						$$.lineno		=$1.lineno;
					};
optional_render_state_list:	'{' render_state_list '}'
					{
						$$.lineno		=$2.lineno;
					}|
					{
					}
// render_state_list must pass up an array of commands. Each command has a name, a number, and a value.
render_state_list : render_state_list render_state_command
					{
						$$.lineno		=$2.lineno;
					}
					|
					render_state_command
					{
						$$.lineno		=$1.lineno;
					};
render_state_command : render_state_identifier '=' render_state_rvalue ';'
					   {
							$$.lineno		=$3.lineno;
							string name		=$1.strs[0];
							string value	=$3.strs[0];
							int index		=$1.num;
							int ival		=$3.num;
							float fval		=$3.fnum;
							bool bval		=(ival!=0);
							if(renderState==RASTERIZER_STATE)
							{
								if(is_equal(name,"FillMode"))
									buildRasterizerState.FillMode=(GLenum)toFillModeGLenum(value);
								else if(is_equal(name,"CullMode"))
									buildRasterizerState.CullMode=(GLenum)toCullModeGLenum(value);
								else if(is_equal(name,"FrontCounterClockwise"))
									buildRasterizerState.FrontCounterClockwise=toBool(value);
								else if(is_equal(name,"DepthBias"))
									buildRasterizerState.DepthBias=ival;
								else if(is_equal(name,"DepthBiasClamp"))
									buildRasterizerState.DepthBiasClamp=fval;
								else if(is_equal(name,"SlopeScaledDepthBias"))
									buildRasterizerState.SlopeScaledDepthBias=fval;
								else if(is_equal(name,"DepthClipEnable"))
									buildRasterizerState.DepthClipEnable=toBool(value);
								else if(is_equal(name,"ScissorEnable"))
									buildRasterizerState.ScissorEnable=toBool(value);
								else if(is_equal(name,"MultisampleEnable"))
									buildRasterizerState.MultisampleEnable=toBool(value);
								else if(is_equal(name,"AntialiasedLineEnable"))
									buildRasterizerState.AntialiasedLineEnable=toBool(value);
								else
								{
									ostringstream str;
									str<<"Unknown rasterizer state command: "<<name;
									errSem(str.str().c_str());
								}
							}
							if(renderState==DEPTHSTENCIL_STATE)
							{
								if(is_equal(name,"DepthEnable"))
									buildDepthStencilState.DepthEnable		=toBool(value);
								else if(is_equal(name,"DepthWriteMask"))
								{
									if(is_equal(value,"ALL"))
										buildDepthStencilState.DepthWriteMask	=1;
									else if(is_equal(value,"ZERO"))
										buildDepthStencilState.DepthWriteMask	=0;
									else 
										errSem("Unknown depth write mask");
								}
								else if(is_equal(name,"DepthFunc"))
									buildDepthStencilState.DepthFunc=(GLenum)toDepthFuncGLEnum(value);
								else
								{
									ostringstream str;
									str<<"Unknown DepthStencil state command: "<<name;
									errSem(str.str().c_str());
								}
							}
							if(renderState==BLEND_STATE)
							{
								if(is_equal(name,"SrcBlend"))
									buildBlendState.SrcBlend=(GLenum)toBlendGLEnum(value);
								else if(is_equal(name,"DestBlend"))
									buildBlendState.DestBlend=(GLenum)toBlendGLEnum(value);
								else if(is_equal(name,"BlendOp"))
									buildBlendState.BlendOp=(GLenum)toBlendOpGLEnum(value);
								else if(is_equal(name,"SrcBlendAlpha"))
									buildBlendState.SrcBlendAlpha=(GLenum)toBlendGLEnum(value);
								else if(is_equal(name,"DestBlendAlpha"))
									buildBlendState.DestBlendAlpha=(GLenum)toBlendGLEnum(value);
								else if(is_equal(name,"BlendOpAlpha"))
									buildBlendState.BlendOpAlpha=(GLenum)toBlendOpGLEnum(value);
								else if(is_equal(name,"AlphaToCoverageEnable"))
									buildBlendState.AlphaToCoverageEnable=toBool(value);
								else if(is_equal(name,"BlendEnable"))
									buildBlendState.BlendEnable[index]=toBool(value);
								else if(is_equal(name,"RenderTargetWriteMask"))
									buildBlendState.RenderTargetWriteMask[index]=ival;
								else
								{
									ostringstream str;
									str<<"Unknown blend state command: "<<name;
									errSem(str.str().c_str());
								}
							}
							if(renderState==SAMPLER_STATE)
							{
								if(is_equal(name,"Filter"))
								{
									buildSamplerState.MinFilter			=(GLenum)toMinFilterModeGLEnum(value);
									buildSamplerState.MagFilter			=(GLenum)toMagFilterModeGLEnum(value);
								}
								else if(is_equal(name,"AddressU"))
									buildSamplerState.AddressU			=(GLenum)toAddressModeGLEnum(value);
								else if(is_equal(name,"AddressV"))
									buildSamplerState.AddressV			=(GLenum)toAddressModeGLEnum(value);
								else if(is_equal(name,"AddressW"))
									buildSamplerState.AddressW			=(GLenum)toAddressModeGLEnum(value);
								else
								{
									ostringstream str;
									str<<"Unknown Sampler state command: "<<name;
									errSem(str.str().c_str());
								}
							}
						};
						|
						ignore_line_statement
						{
							$$.lineno	=$1.lineno;
							$$.num		=-1;
						};
render_state_identifier : IDENTIFIER optional_index
						{
							$$.lineno	=$1.lineno;
							$$.strs[0]	=$1.strs[0];
							$$.num		=$2.num;
						};
optional_index : '[' NUM ']'
						{
							 $$.num=$2.num;
							 $$.fnum=$2.fnum;
						}
						|
						{
							 $$.num=0;
						};
render_state_rvalue : IDENTIFIER
						{
							$$.lineno=$1.lineno;
							$$.strs[0]=$1.strs[0];
						}
						| NUM
						{
							$$.lineno=$1.lineno;
							$$.num=$1.num;
						}
						| FLOAT
						{
							$$.lineno=$1.lineno;
							$$.fnum=$1.fnum;
						};
type_spec: IDENTIFIER
		{
			$$.strs[0]=$1.strs[0];
		}
%%

void glfxWarning(const char* e)
{
    ostringstream errMsg;
	int lex_linenumber=glfxget_lineno();
	int true_linenumber=lex_linenumber+last_linenumber-global_linenumber;
    errMsg<<current_filenumber<<"("<< true_linenumber<<") : glfx warning: \""<<glfxget_text()<<"\" "<<e;
	gEffect->Log()<<errMsg;
}

void glfxerror(const char* e)
{
    errSyn(e);
}

void errSyn(const char* e)
{
    ostringstream errMsg;
	int lex_linenumber=glfxget_lineno();
	int true_linenumber=lex_linenumber+last_linenumber-global_linenumber;
    errMsg<<current_filenumber<<"("<< true_linenumber<<") : glfx syntax error: \""<<glfxget_text()<<"\" "<<e<<" in "<<glfxGetStateText();
    throw std::runtime_error(errMsg.str());
}

void errSem(const string& str, int lex_linenumber)
{
    ostringstream errMsg;
    
    if(lex_linenumber==-1)
        lex_linenumber= glfxget_lineno();
	int true_linenumber=lex_linenumber+last_linenumber-global_linenumber;
    errMsg<<current_filenumber<<"("<<true_linenumber<<") : glfx error: "<<str<<" in "<<glfxGetStateText();
    throw errMsg.str();
}
