%name-prefix "glfx"
%output "src/glfxLALRParser.cpp"
%defines "src/glfxLALRParser.hpp"
%{
    #include <iostream>
    #include <map>
    #include <string>
    #include <vector>
    #include <sstream>
    
    #include "glfxParser.h"
    #include "glfxClasses.h"

    using namespace std;
    using namespace glfxParser;
    
    #ifdef _MSC_VER
    // MS's C++ compiler is more strict than gcc
    
    // bison related
    // Disable the warning about default being present but no other cases in switch
    #pragma warning( disable:4065 )

    // No unistd.h (for flex)
    #define YY_NO_UNISTD_H
	#define YYERROR_VERBOSE
    
    #endif
    #include "glfxScanner.h"
    #include "glfxEffect.h"

    static void errSyn(const char *e);
    static void errSem(const string& str, int line=-1);
	static int last_linenumber=0;
	static int current_filenumber=0;
	static int global_linenumber=0;
	std::string currentCsLayout;
	int last_recorded_linenum	=0;
	int global_linenum			=0;
	int filenum					=0;
	#pragma optimize("",off)
%}

%token 	SHADER PROGRAM INTERFACE IDENTIFIER STORAGEQ GL_FRAGDEPTH STORAGET SHADER_TYPE SHADER_COMMAND
%token	LP RP LB RB SC COMMA COLON EQUALS NUM INCLUDE SAMPLER FLOAT EMPTY_ARRAY_BRACKETS
%token  LAYOUT LINE TECHNIQUE PASS GROUP RENDER_STATE QUOTED_STRING

%%

prog : prog tok
    | { // Initialization code
    gEffect->m_sharedCode.str("");    // clear the stream
    //gEffect->m_sharedCode<<"#line "<<glfxget_lineno()<<" "<<gEffect->Filename().c_str()<<endl;
    gLexPassthrough=true;
	};
	tok : INTERFACE lex_fx IDENTIFIER read_block SC lex_passthrough
	{
		gEffect->m_interfaces[$3.strs[0]]=Effect::InterfaceDcl($4.strs[0], $1.lineno);
	}
	| LINE lex_fx NUM NUM lex_passthrough
	{
		last_linenumber=$3.num;
		current_filenumber=$4.num;
		global_linenumber=$1.lineno;
		gEffect->m_sharedCode<<$1.strs[0]<<" "<<$3.num<<" "<<$4.num<<endl;
	}
    | shader_and_layout IDENTIFIER LP param_list RP read_block lex_passthrough
	{
		ostringstream shaderCode;
		int true_linenumber=$1.lineno+(last_linenumber-global_linenumber);
		// Add shader parameters
		for(vector<YYSTYPE::variable>::const_iterator it=$4.vars->begin();it!=$4.vars->end();++it)
		{
			string type(it->type);
			map<string, Effect::InterfaceDcl>::const_iterator varType=gEffect->m_interfaces.find(type);
			int lineno;
			if(varType!=gEffect->m_interfaces.end())
			{
				type+=varType->second.id;
				lineno=varType->second.atLine;
			}
			else
				lineno=$1.lineno;
		// First put #line in to make sure that all our definitions produce correct-looking warnings/errors.
			shaderCode<<"#line "<<true_linenumber<<" "<<current_filenumber<<endl;
			shaderCode<<it->prepend<<' '<<type<<' '<<it->identifier<<';'<<endl;
		}
		delete $4.vars;
		std::string shaderName=$3.strs[0];
		// Add definition and code
		shaderCode<<"#line "<<true_linenumber<<" "<<current_filenumber<<endl;
		shaderCode<<currentCsLayout<<"\nvoid main()"<<endl<<$6.strs[0];//<<"#line "<<$7.lineno<<" "<<gEffect->Filename().c_str()<<endl<<$7.strs[0];
		gEffect->m_shaders[shaderName]=shaderCode.str();
		// now we must put a #line directive in the shared code, because we've just snipped out a bunch of what was there:
		
		gEffect->m_sharedCode<<"#line "<<(glfxget_lineno()+(last_linenumber-global_linenumber))<<" "<<current_filenumber<<endl;
	}
    | PROGRAM lex_fx IDENTIFIER LB prog_def RB lex_passthrough
	{
		$5.prog->m_separable=$1.boolean;
		gEffect->m_programs[$3.strs[0]]=$5.prog;
	}
	| TECHNIQUE lex_fx IDENTIFIER LB tech_def RB lex_passthrough
	{
		gEffect->m_techniques[$3.strs[0]] = $5.tech;
	}
    | INCLUDE
	{
		FILE* includeF;
		string fName(gEffect->Dir());
		fName+=$1.strs[0];
		fopen_s(&includeF, fName.c_str(), "rb");
		if(!includeF)
			errSem("Cannot open include file", $1.lineno);
		fseek(includeF, 0, SEEK_END);
		int size=ftell(includeF)+1;
		unsigned char* includeStr=new unsigned char[size];
		rewind(includeF);
		fread(includeStr, 1, size, includeF);
		includeStr[size-1]=0;
    
		gEffect->m_includes++;
	 //   gEffect->m_sharedCode<<"#line 1 \""<<fName.c_str()<<"\""<<endl;//gEffect->m_includes
		gEffect->m_sharedCode<<includeStr<<endl;
	   // gEffect->m_sharedCode<<"#line "<<$1.lineno+1<<" "<<gEffect->Filename().c_str()<<endl;
    
		fclose(includeF);
		delete[] includeStr;
	}
    | SAMPLER lex_fx samplerClass LB samplerParamList RB samplerVars SC lex_passthrough
	{
		Sampler* samp=$5.samp;
		samp->SetParam("Type", $1.strs[0]);
		string dcl=samp->Descriptor();
		if(dcl.size() == 0)
			errSem("No sampler declaration can be generated", $1.lineno);
		if($3.strs[0].size()>0)
			gEffect->m_samplers[$3.strs[0]]=new Sampler(*samp);
		for(vector<YYSTYPE::samplerVar>::const_iterator it=$7.texNames->begin(); it!=$7.texNames->end(); ++it)
		{
			//gEffect->m_sharedCode<<"#line "<<$1.lineno<<" "<<gEffect->Filename().c_str()<<endl;
			gEffect->m_sharedCode<<it->binding<<" uniform "<<dcl<<' '<<it->name<<';'<<endl;
			gEffect->m_samplers[it->name]=new Sampler(*samp);
		}
		delete samp;
		delete $7.texNames;
		//gEffect->m_sharedCode<<"#line "<<glfxget_lineno()<<" "<<gEffect->Filename().c_str()<<endl;
	}
;
shader_and_layout: SHADER lex_fx cslayout
	{
	string s1=$1.strs[0];
	$$.strs[0]=s1;
	 };
	cslayout: LAYOUT layout_params
	{
		currentCsLayout="";
		currentCsLayout+=$1.strs[0];
		currentCsLayout+=$2.strs[0];
	}
	 | {
   currentCsLayout= "";
};

layout_params:LP NUM COMMA NUM COMMA NUM RP
{
	std::string ret="(";
	ret+=$2.strs[0];
	ret+=",";
	ret+=$4.strs[0];
	ret+=",";
	ret+=$6.strs[0];
	ret+=")";
	$$.strs[0]=ret;
};
lex_fx :
{ /* Switch lex to fx scanning */
    gLexPassthrough=false;
}
;

number_or_filename : NUM
					 {
						 $$.num=$1.num;
						 $$.strs[0]=$1.strs[0];
					 }
					 | QUOTED_STRING
					 {
						 $$.strs[0]=$1.strs[0];
					 };
lex_passthrough :
{ /* Switch lex to passthrough mode */
    gLexPassthrough=true;
}
;

read_block : { /* Read next block */
    $$.lineno=glfxget_lineno();
    $$.strs[0]=glfxreadblock('{', '}');
}
;

samplerClass : IDENTIFIER {
    $$.strs[0]=$1.strs[0];
}
    | {
    $$.strs[0]="";
}
;

samplerVars : samplerVars COMMA samplerVar {
    $$.texNames=$1.texNames;
    
    YYSTYPE::samplerVar sv;
    sv.binding=$3.strs[0];
    sv.name=$3.strs[1];
    $$.texNames->push_back(sv);
}
    | samplerVar {
    $$.texNames=new vector<YYSTYPE::samplerVar>;
    YYSTYPE::samplerVar sv;
    sv.binding=$1.strs[0];
    sv.name=$1.strs[1];
    $$.texNames->push_back(sv);
}
;

samplerVar : IDENTIFIER location {
    ostringstream prepend;
    switch($2.rType) {
    case REGISTER_INT:
        prepend<<"layout(binding="<<$2.num<<") ";
        break;
    case REGISTER_NAME:
        prepend<<"layout(binding="<<$2.strs[0]<<") ";
        break;
    }
    
    $$.strs[0]=prepend.str();
    $$.strs[1]=$1.strs[0];
}
;
    

samplerParamList : samplerParamList samplerParam SC {
    $$.samp=$1.samp;
    switch($2.samplerParamType) {
    case SAMPLER_PARAM_STRING:
        $$.samp->SetParam($2.strs[0], $2.strs[1]);
        break;
    case SAMPLER_PARAM_INT:
        $$.samp->SetParam($2.strs[0], $2.unum);
        break;
    case SAMPLER_PARAM_FLOAT:
        $$.samp->SetParam($2.strs[0], $2.fnum);
        break;
    }
}
    | samplerParam SC {
    $$.samp=new Sampler();
    switch($1.samplerParamType) {
    case SAMPLER_PARAM_STRING:
        $$.samp->SetParam($1.strs[0], $1.strs[1]);
        break;
    case SAMPLER_PARAM_INT:
        $$.samp->SetParam($1.strs[0], $1.unum);
        break;
    case SAMPLER_PARAM_FLOAT:
        $$.samp->SetParam($1.strs[0], $1.fnum);
        break;
    }
}
;

samplerParam : IDENTIFIER EQUALS IDENTIFIER {
    $$.strs[0]=$1.strs[0];
    $$.strs[1]=$3.strs[0];
    $$.samplerParamType=SAMPLER_PARAM_STRING;
}
    | IDENTIFIER EQUALS FLOAT {
    $$.strs[0]=$1.strs[0];
    $$.fnum=$3.fnum;
    $$.samplerParamType=SAMPLER_PARAM_FLOAT;
}
    | IDENTIFIER EQUALS NUM {
    $$.strs[0]=$1.strs[0];
    $$.num=$3.num;
    $$.samplerParamType=SAMPLER_PARAM_INT;
}
;

param_list : param_list COMMA fullparam {
    $$.vars=$1.vars;

    YYSTYPE::variable var;
    var.prepend=$3.strs[0];
    var.type=$3.strs[1];
    var.identifier=$3.strs[2];
    
    $$.vars->push_back(var);
}
    | fullparam {
    YYSTYPE::variable var;
    var.prepend=$1.strs[0];
    var.type=$1.strs[1];
    var.identifier=$1.strs[2];
    
    $$.vars = new vector<YYSTYPE::variable>;
    $$.vars->push_back(var);
}
    | {
    $$.vars = new vector<YYSTYPE::variable>;
}
;

fullparam : storage param arrayBrackets location {
    ostringstream prepend;

    switch($4.rType) {
    case REGISTER_INT:
        prepend<<"layout(location="<<$4.num<<") ";
        break;
    case REGISTER_NAME:
        prepend<<"layout(location="<<$4.strs[0]<<") ";
        break;
    }
    
    prepend<<$1.strs[0]<<' '<<$2.strs[0];
    $$.strs[0]=prepend.str();
    $$.strs[1]=$2.strs[1];
    $$.strs[2]=$2.strs[2];
    $$.strs[2]+=$3.strs[0];
}
;

storage : STORAGET {
    $$.strs[0]=$1.strs[0];
}
    | { /* None */
    $$.strs[0]="";
}
;

param : STORAGEQ IDENTIFIER IDENTIFIER
	{
		$$.strs[0]=$1.strs[0];
		$$.strs[1]=$2.strs[0];
		$$.strs[2]=$3.strs[0];
	}
;

arrayBrackets : EMPTY_ARRAY_BRACKETS
	{
		$$.strs[0]="[]";
	}
    |
	{
		$$.strs[0]="";
	}
;

location : COLON NUM
	{
		$$.num=$2.num;
		$$.rType=REGISTER_INT;
	}
    | COLON IDENTIFIER
	{
		$$.strs[0]=$2.strs[0];
		$$.rType=REGISTER_NAME;
	}
    |
	{
		$$.rType=REGISTER_NONE;
	}
;

tech_def : pass_list
{
	Technique *t = new Technique(*($1.passes));
	$$.tech = t;
	delete $1.passes;
};

pass_list: pass_list pass_def
{
	$$.passes = $1.passes;
	string name = $2.strs[0];
	Program *p = $2.prog;
	if (p)
	{
		(*$$.passes)[name] = *(p);
	}
	delete $2.prog;
}
| pass_def
{
	map < string, Program > *m=new map < string, Program >;
	$$.passes = m;
	string name = $1.strs[0];
	Program *p = $1.prog;
	if (p)
	{
		Program &newp = (*m)[name];
		newp= *p;
	}
	delete p;
}
;

pass_def: PASS IDENTIFIER LB prog_def RB
{
	$4.prog->m_separable = $1.boolean;
	$$.prog = $4.prog;
	$$.strs[0] = $2.strs[0];
}

prog_def : shaders_list
	{
		$$.prog = new Program(*($1.shaders));
		delete $1.shaders;
	}
	;

shaders_list : shaders_list shader_def
	{
		$$.shaders=$1.shaders;
		(*$$.shaders)[$2.sType].src=$2.strs[0];
		(*$$.shaders)[$2.sType].name=$2.strs[1];
	}
	| shader_def
	{
		$$.shaders=new map<ShaderType, Program::Shader>;
		(*$$.shaders)[$1.sType].src=$1.strs[0];
		(*$$.shaders)[$1.sType].name=$1.strs[1];
	}
	;
	
shader_def : shader_lvalue shader_rvalue SC
{
	// Assemble the shader
	ostringstream theShader;
	theShader<<"#version "<<$1.num<<endl;
	theShader<<$2.strs[1];
	glfxParser::ShaderType shaderType=$1.sType;
	glfxParser::ShaderCommand shaderCommand=$1.sCommand;
	// RVK: Must do this because layout(u,v,w) causes problems for non-compute shaders in some compilers:
	if(shaderType==COMPUTE_SHADER)
		theShader<<"#define USE_GL_COMPUTE_SHADER"<<endl;
	if(shaderType<NUM_OF_SHADER_TYPES&&$2.num>0)
	{
		string shaderName=($2.strs[0]);
		if(_stricmp(shaderName.c_str(),"NULL")!=0)
		{
			theShader<<gEffect->m_sharedCode.str();
			map<string, string>::const_iterator it=gEffect->m_shaders.find(shaderName);
			if(it==gEffect->m_shaders.end())
			{
				ostringstream errMsg;
				errMsg<<"Unable to find referenced shader \""<<shaderName<<'\"';
				errSem(errMsg.str(), $2.lineno);
			}
			// Currently in case of error it never returns (throw)
			// TODO: Handle continuation in case of error
			theShader<<it->second;
		}
		$$.strs[1]=shaderName;
		$$.strs[0]=theShader.str();
	}
	else if(shaderCommand<NumShaderCommands)
	{
		$$.strs[0]=$1.strs[1];
		$$.strs[1]=$1.strs[0];
	}
	$$.sType=$1.sType;
};
//shader_def : SHADER_COMMAND LP IDENTIFIER RP shader_layout SC
shader_lvalue : SHADER_TYPE LP NUM RP
{
	$$.num=$3.num;
	$$.sType=$1.sType;
}
| SHADER_COMMAND LP IDENTIFIER RP
{
	ostringstream theShader;
	$$.num=$3.num;
	$$.sCommand=$1.sCommand;
	glfxParser::ShaderCommand shaderCommand=$1.sCommand;
	if(shaderCommand==COMPUTE_SHADER)
		theShader<<"#define USE_GL_COMPUTE_SHADER"<<endl;
	if(shaderCommand<NumShaderCommands)
	{
		string shaderName=($3.strs[0]);
		if(_stricmp(shaderName.c_str(),"NULL")!=0)
		{
			theShader<<gEffect->m_sharedCode.str();
			map<string, string>::const_iterator it=gEffect->m_shaders.find(shaderName);
			if(it==gEffect->m_shaders.end())
			{
				ostringstream errMsg;
				errMsg<<"Unable to find referenced shader \""<<shaderName<<'\"';
				errSem(errMsg.str(), $3.lineno);
			}
			// Currently in case of error it never returns (throw)
			// TODO: Handle continuation in case of error
			theShader<<it->second;
		}
		$$.strs[0]=shaderName;
		$$.strs[1]=theShader.str();
	}
};
shader_rvalue : EQUALS IDENTIFIER LP RP shader_layout
{
	$$.lineno=$2.lineno;
	$$.strs[0]=$2.strs[0];
	$$.strs[1]=$5.strs[0];
	$$.num=2;
}
|
{
	$$.num=0;
};
shader_layout : COLON shader_layout_list
{
	$$.strs[0]=$2.strs[0];
}
|
{
	$$.strs[0]="";
};

shader_layout_list : shader_layout_list COMMA layout
	{
		$$.strs[0]=$1.strs[0];
		$$.strs[0]+=$3.strs[0];
	}
    | layout
	{
		$$.strs[0]=$1.strs[0];
	}
;

layout : STORAGEQ read_parenthesis
	{
		ostringstream layoutDef;
		//layoutDef<<"#line "<<$1.lineno<<endl;
		layoutDef<<"layout"<<$2.strs[0]<<' '<<$1.strs[0]<<';'<<endl;
		$$.strs[0]=layoutDef.str();
	}
;

layout : GL_FRAGDEPTH read_parenthesis
	{
		ostringstream layoutDef;
		//layoutDef<<"#line "<<$1.lineno<<endl;
		layoutDef<<"layout"<<$2.strs[0]<<' '<<"out float "<<$1.strs[0]<<';'<<endl;
		$$.strs[0]=layoutDef.str();
	}
;

read_parenthesis :
	{ /* read parenthesis */
		$$.strs[0]=glfxreadblock('(', ')');
	}
;

%%

void glfxerror(const char* e)
{
    errSyn(e);
}

void errSyn(const char* e)
{
    ostringstream errMsg;

    errMsg<<"0("<<glfxget_lineno()<<") : error: Syntax error, "<<glfxget_text()<<" "<<e;
    throw errMsg.str();
}

void errSem(const string& str, int line)
{
    ostringstream errMsg;
    
    if(line==-1)
        line=glfxget_lineno();
    errMsg<<"0("<<line<<") : error: "<<str;
    throw errMsg.str();
}
